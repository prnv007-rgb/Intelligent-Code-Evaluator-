[
  {
    "title": "Two Sum",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        prevMap = {}  # val -> index\n\n        for i, n in enumerate(nums):\n            diff = target - n\n            if diff in prevMap:\n                return [prevMap[diff], i]\n            prevMap[n] = i",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Hash Map"
  },
  {
    "title": "Add Two Numbers",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        dummy = ListNode()\n        cur = dummy\n\n        carry = 0\n        while l1 or l2 or carry:\n            v1 = l1.val if l1 else 0\n            v2 = l2.val if l2 else 0\n\n            val = v1 + v2 + carry\n            carry = val // 10\n            val = val % 10\n            cur.next = ListNode(val)\n\n            cur = cur.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy.next",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "linked list",
      "math"
    ],
    "approach": "The main algorithmic approach used is \"Iterative\" with a hint of \"Simple Arithmetic\". However, among common terms, I'd say it's primarily using the \"Two Pointers\" technique."
  },
  {
    "title": "Longest Substring Without Repeating Characters",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        charSet = set()\n        l = 0\n        res = 0\n\n        for r in range(len(s)):\n            while s[r] in charSet:\n                charSet.remove(s[l])\n                l += 1\n            charSet.add(s[r])\n            res = max(res, r - l + 1)\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "hash table"
    ],
    "approach": "Sliding Window"
  },
  {
    "title": "Median Of Two Sorted Arrays",
    "description": "No description available.",
    "optimal_code": "\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        A, B = nums1, nums2\n        total = len(nums1) + len(nums2)\n        half = total // 2\n\n        if len(B) < len(A):\n            A, B = B, A\n\n        l, r = 0, len(A) - 1\n        while True:\n            i = (l + r) // 2  # A\n            j = half - i - 2  # B\n\n            Aleft = A[i] if i >= 0 else float(\"-infinity\")\n            Aright = A[i + 1] if (i + 1) < len(A) else float(\"infinity\")\n            Bleft = B[j] if j >= 0 else float(\"-infinity\")\n            Bright = B[j + 1] if (j + 1) < len(B) else float(\"infinity\")\n\n            if Aleft <= Bright and Bleft <= Aright:\n                if total % 2:\n                    return min(Aright, Bright)\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2\n            elif Aleft > Bright:\n                r = i - 1\n            else:\n                l = i + 1",
    "time_complexity": "O(log n)",
    "space_complexity": "O(1)",
    "tags": [
      "binary search",
      "math"
    ],
    "approach": "Binary Search."
  },
  {
    "title": "Longest Palindromic Substring",
    "description": "No description available.",
    "optimal_code": "\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        self.res = \"\"\n        self.lenres = 0\n        for i in range(len(s)):\n            s1 = self.helper(s, i, i)\n            s2 = self.helper(s, i, i + 1)\n        return s2\n        \n    def helper(self, s, left, right):\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                if (right - left + 1) > self.lenres:\n                    self.res = s[left:right+1]\n                    self.lenres = right - left + 1\n                left -= 1\n                right += 1\n            return self.res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "array"
    ],
    "approach": "The main algorithmic approach used is \"Expansion Around Center\". This approach involves expanding around a center point to find the longest palindromic substring."
  },
  {
    "title": "Zigzag Conversion",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1 or numRows >= len(s):\n            return s\n\n        res = [\"\"] * numRows\n\n        index = 0\n        step = 1\n        for c in s:\n            res[index] += c\n            if index == 0:\n                step = 1\n            elif index == numRows - 1:\n                step = -1\n            index += step\n\n        return \"\".join(res)",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Two Pointers\"."
  },
  {
    "title": "Reverse Integer",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def reverse(self, x: int) -> int:\n\n        MIN = -2147483648  # -2^31,\n        MAX = 2147483647  #  2^31 - 1\n\n        res = 0\n        while x:\n            digit = int(math.fmod(x, 10))  # (python dumb) -1 %  10 = 9\n            x = int(x / 10)  # (python dumb) -1 // 10 = -1\n\n            if res > MAX // 10 or (res == MAX // 10 and digit > MAX % 10):\n                return 0\n            if res < MIN // 10 or (res == MIN // 10 and digit < MIN % 10):\n                return 0\n            res = (res * 10) + digit\n\n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "math"
    ],
    "approach": "The main algorithmic approach used is \"Modulus/Division\" and also involves \"Integer Arithmetic\"."
  },
  {
    "title": "Palindrome Number",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0: return False\n        \n        div = 1\n        while x >= 10 * div:\n            div *= 10\n            \n        while x:\n            right = x % 10\n            left = x // div\n            \n            if left != right: return False\n            \n            x = (x % div) // 10\n            div = div / 100\n        return True",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "\"Divide and Conquer\" with \"Two Pointers\""
  },
  {
    "title": "Regular Expression Matching",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        cache = [[False] * (len(p) + 1) for i in range(len(s) + 1)]\n        cache[len(s)][len(p)] = True\n\n        for i in range(len(s), -1, -1):\n            for j in range(len(p) - 1, -1, -1):\n                match = i < len(s) and (s[i] == p[j] or p[j] == \".\")\n\n                if (j + 1) < len(p) and p[j + 1] == \"*\":\n                    cache[i][j] = cache[i][j + 2]\n                    if match:\n                        cache[i][j] = cache[i + 1][j] or cache[i][j]\n                elif match:\n                    cache[i][j] = cache[i + 1][j + 1]\n\n        return cache[0][0]\n\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        cache = {}\n\n        def dfs(i, j):\n            if (i, j) in cache:\n                return cache[(i, j)]\n            if i >= len(s) and j >= len(p):\n                return True\n            if j >= len(p):\n                return False\n\n            match = i < len(s) and (s[i] == p[j] or p[j] == \".\")\n            if (j + 1) < len(p) and p[j + 1] == \"*\":\n                cache[(i, j)] = dfs(i, j + 2) or (  # dont use *\n                    match and dfs(i + 1, j)\n                )  # use *\n                return cache[(i, j)]\n            if match:\n                cache[(i, j)] = dfs(i + 1, j + 1)\n                return cache[(i, j)]\n            cache[(i, j)] = False\n            return False\n\n        return dfs(0, 0)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "dfs",
      "dynamic programming",
      "hash table",
      "recursion"
    ],
    "approach": "The main algorithmic approach used is \"Dynamic Programming\" or more specifically \"Memoized Dynamic Programming\"."
  },
  {
    "title": "Container With Most Water",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        l, r = 0, len(height) - 1\n        res = 0\n\n        while l < r:\n            res = max(res, min(height[l], height[r]) * (r - l))\n            if height[l] < height[r]:\n                l += 1\n            elif height[r] <= height[l]:\n                r -= 1\n            \n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "sliding window",
      "two pointers"
    ],
    "approach": "Two Pointers"
  },
  {
    "title": "Integer To Roman",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        symList = [\n            [\"I\", 1],\n            [\"IV\", 4],\n            [\"V\", 5],\n            [\"IX\", 9],\n            [\"X\", 10],\n            [\"XL\", 40],\n            [\"L\", 50],\n            [\"XC\", 90],\n            [\"C\", 100],\n            [\"CD\", 400],\n            [\"D\", 500],\n            [\"CM\", 900],\n            [\"M\", 1000],\n        ]\n        res = \"\"\n        for sym, val in reversed(symList):\n            if num // val:\n                count = num // val\n                res += sym * count\n                num = num % val\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "math"
    ],
    "approach": "Greedy"
  },
  {
    "title": "Roman To Integer",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        roman = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\n        res = 0\n        for i in range(len(s)):\n            if i + 1 < len(s) and roman[s[i]] < roman[s[i + 1]]:\n                res -= roman[s[i]]\n            else:\n                res += roman[s[i]]\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "array"
    ],
    "approach": "Greedy"
  },
  {
    "title": "Longest Common Prefix",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        for i in range(len(strs[0])):\n            for s in strs:\n                if i >= len(s) or s[i] != strs[0][i]:\n                    return strs[0][:i]\n        return strs[0]",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "array"
    ],
    "approach": "\"Two Pointers\" (or rather, \"One Pointer\")"
  },
  {
    "title": "3Sum",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        nums.sort()\n\n        for i, a in enumerate(nums):\n            if a > 0:\n                break\n\n            if i > 0 and a == nums[i - 1]:\n                continue\n\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                threeSum = a + nums[l] + nums[r]\n                if threeSum > 0:\n                    r -= 1\n                elif threeSum < 0:\n                    l += 1\n                else:\n                    res.append([a, nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while nums[l] == nums[l - 1] and l < r:\n                        l += 1\n                        \n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "sliding window",
      "two pointers"
    ],
    "approach": "Two Pointers"
  },
  {
    "title": "3Sum Closest",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n\n        nums.sort()\n        best = float('inf')\n        \n        for i in range(len(nums) - 2):\n            \n            val = nums[i]\n            left = i + 1\n            right = len(nums) - 1\n            \n            while left < right:\n                \n                currentGap = abs(target - (val + nums[left] + nums[right]))\n                \n                if abs(best - target) > currentGap:\n                    best = val + nums[left] + nums[right]\n                if val + nums[left] + nums[right] < target:\n                    left += 1\n                elif val + nums[left] + nums[right] > target:\n                    right -= 1\n                else: #closest it can get \n                    return target                \n                \n        return best",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "array"
    ],
    "approach": "The main algorithmic approach used is \"Two Pointers\"."
  },
  {
    "title": "Letter Combinations Of A Phone Number",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        res = []\n        digitToChar = {\n            \"2\": \"abc\",\n            \"3\": \"def\",\n            \"4\": \"ghi\",\n            \"5\": \"jkl\",\n            \"6\": \"mno\",\n            \"7\": \"qprs\",\n            \"8\": \"tuv\",\n            \"9\": \"wxyz\",\n        }\n\n        def backtrack(i, curStr):\n            if len(curStr) == len(digits):\n                res.append(curStr)\n                return\n            for c in digitToChar[digits[i]]:\n                backtrack(i + 1, curStr + c)\n\n        if digits:\n            backtrack(0, \"\")\n\n        return res",
    "time_complexity": "O(log n)",
    "space_complexity": "O(n)",
    "tags": [
      "binary search"
    ],
    "approach": "The main algorithmic approach used is \"Backtracking\"."
  },
  {
    "title": "4Sum",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def fourSum(self, nums, target):\n        def findNsum(l, r, target, N, result, results):\n            if r-l+1 < N or N < 2 or target < nums[l]*N or target > nums[r]*N:  \n                return\n            if N == 2: \n                while l < r:\n                    s = nums[l] + nums[r]\n                    if s == target:\n                        results.append(result + [nums[l], nums[r]])\n                        l += 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n            else:\n                for i in range(l, r+1):\n                    if i == l or (i > l and nums[i-1] != nums[i]):\n                        findNsum(i+1, r, target-nums[i], N-1, result+[nums[i]], results)\n\n        nums.sort()\n        results = []\n        findNsum(0, len(nums)-1, target, 4, [], results)\n        return results",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "sliding window",
      "two pointers"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Remove Nth Node From End Of List",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        dummy = ListNode(0, head)\n        left = dummy\n        right = head\n\n        while n > 0:\n            right = right.next\n            n -= 1\n\n        while right:\n            left = left.next\n            right = right.next\n\n        left.next = left.next.next\n        return dummy.next",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "linked list"
    ],
    "approach": "Two Pointers."
  },
  {
    "title": "Valid Parentheses",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isValid(self, s: str) -> bool:\n        bracketMap = {\")\": \"(\", \"]\": \"[\", \"}\": \"{\"}\n        stack = []\n\n        for c in s:\n            if c not in bracketMap:\n                stack.append(c)\n                continue\n            if not stack or stack[-1] != bracketMap[c]:\n                return False\n            stack.pop()\n\n        return not stack",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Stack\" (or \"Queue\") with a hint of \"Matching\" (as it's checking if the brackets match). However, given the common terms, I would say that the main approach is \"Stack\"."
  },
  {
    "title": "Merge Two Sorted Lists",
    "description": "No description available.",
    "optimal_code": "\nclass Solution:\n    def mergeTwoLists(self, list1: ListNode, list2: ListNode) -> ListNode:\n        dummy = node = ListNode()\n\n        while list1 and list2:\n            if list1.val < list2.val:\n                node.next = list1\n                list1 = list1.next\n            else:\n                node.next = list2\n                list2 = list2.next\n            node = node.next\n\n        node.next = list1 or list2\n\n        return dummy.next\n    \nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        lil, big = (list1, list2) if list1.val < list2.val else (list2, list1)\n        lil.next = self.mergeTwoLists(lil.next, big)\n        return lil",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "linked list"
    ],
    "approach": "The main algorithmic approach used in both solutions is \"Recursion\" and/or \"Divide-and-Conquer\" with a hint of \"Comparison-based sorting\"."
  },
  {
    "title": "Generate Parentheses",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        stack = []\n        res = []\n\n        def backtrack(openN, closedN):\n            if openN == closedN == n:\n                res.append(\"\".join(stack))\n                return\n\n            if openN < n:\n                stack.append(\"(\")\n                backtrack(openN + 1, closedN)\n                stack.pop()\n            if closedN < openN:\n                stack.append(\")\")\n                backtrack(openN, closedN + 1)\n                stack.pop()\n\n        backtrack(0, 0)\n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Merge K Sorted Lists",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\n        if not lists or len(lists) == 0:\n            return None\n\n        while len(lists) > 1:\n            mergedLists = []\n            for i in range(0, len(lists), 2):\n                l1 = lists[i]\n                l2 = lists[i + 1] if (i + 1) < len(lists) else None\n                mergedLists.append(self.mergeList(l1, l2))\n            lists = mergedLists\n        return lists[0]\n\n    def mergeList(self, l1, l2):\n        dummy = ListNode()\n        tail = dummy\n\n        while l1 and l2:\n            if l1.val < l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        if l1:\n            tail.next = l1\n        if l2:\n            tail.next = l2\n        return dummy.next",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "linked list"
    ],
    "approach": "Divide and Conquer."
  },
  {
    "title": "Swap Nodes In Pairs",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        dummy = ListNode(0, head)\n        prev, curr = dummy, head\n\n        while curr and curr.next:\n            nxtPair = curr.next.next\n            second = curr.next\n\n            second.next = curr\n            curr.next = nxtPair\n            prev.next = second\n\n            prev = curr\n            curr = nxtPair\n\n        return dummy.next",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "linked list"
    ],
    "approach": "The main algorithmic approach used is \"Two Pointers\"."
  },
  {
    "title": "Reverse Nodes In K Group",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\n        dummy = ListNode(0, head)\n        groupPrev = dummy\n\n        while True:\n            kth = self.getKth(groupPrev, k)\n            if not kth:\n                break\n            groupNext = kth.next\n\n            prev, curr = kth.next, groupPrev.next\n            while curr != groupNext:\n                tmp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = tmp\n\n            tmp = groupPrev.next\n            groupPrev.next = kth\n            groupPrev = tmp\n        return dummy.next\n\n    def getKth(self, curr, k):\n        while curr and k > 0:\n            curr = curr.next\n            k -= 1\n        return curr",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "linked list"
    ],
    "approach": "The main algorithmic approach used is \"Two Pointers\"."
  },
  {
    "title": "Remove Duplicates From Sorted Array",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        L = 1\n        \n        for R in range(1, len(nums)):\n            if nums[R] != nums[R - 1]:\n                nums[L] = nums[R]\n                L += 1\n        return L",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "\"Two Pointers\""
  },
  {
    "title": "Remove Element",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        k = 0\n        for i in range(len(nums)):\n            if nums[i] != val:\n                nums[k] = nums[i]\n                k += 1\n        return k\n\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        n = len(nums)\n        i = 0\n\n        while i < n:\n            if nums[i] == val:\n                nums[i], nums[n - 1] = nums[n - 1], nums[i]\n                n -= 1  # decrement the length of the array by discarding the last element\n            else:\n                i += 1\n        \n        return n",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "array"
    ],
    "approach": "\"Single Pass Iteration\""
  },
  {
    "title": "Find The Index Of The First Occurrence In A String",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle == \"\":\n            return 0\n        lps = [0] * len(needle)\n\n        prevLPS, i = 0, 1\n        while i < len(needle):\n            if needle[i] == needle[prevLPS]:\n                lps[i] = prevLPS + 1\n                prevLPS += 1\n                i += 1\n            elif prevLPS == 0:\n                lps[i] = 0\n                i += 1\n            else:\n                prevLPS = lps[prevLPS - 1]\n\n        i = 0  # ptr for haystack\n        j = 0  # ptr for needle\n        while i < len(haystack):\n            if haystack[i] == needle[j]:\n                i, j = i + 1, j + 1\n            else:\n                if j == 0:\n                    i += 1\n                else:\n                    j = lps[j - 1]\n            if j == len(needle):\n                return i - len(needle)\n        return -1",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "KMP (Knuth-Morris-Pratt) algorithm."
  },
  {
    "title": "Search In Rotated Sorted Array",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            mid = (l + r) // 2\n            if target == nums[mid]:\n                return mid\n\n            if nums[l] <= nums[mid]:\n                if target > nums[mid] or target < nums[l]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            else:\n                if target < nums[mid] or target > nums[r]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n        return -1",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "Binary Search."
  },
  {
    "title": "Find First And Last Position Of Element In Sorted Array",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        left = self.binSearch(nums, target, True)\n        right = self.binSearch(nums, target, False)\n        return [left, right]\n\n    def binSearch(self, nums, target, leftBias):\n        l, r = 0, len(nums) - 1\n        i = -1\n        while l <= r:\n            m = (l + r) // 2\n            if target > nums[m]:\n                l = m + 1\n            elif target < nums[m]:\n                r = m - 1\n            else:\n                i = m\n                if leftBias:\n                    r = m - 1\n                else:\n                    l = m + 1\n        return i",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "Binary Search"
  },
  {
    "title": "Search Insert Position",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        \n        \n        low, high = 0, len(nums)\n        while low<high:\n            mid = low +(high - low) // 2\n            if target > nums[mid]:\n                low = mid + 1\n            else:\n                high = mid\n        return low",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "Binary Search"
  },
  {
    "title": "Valid Sudoku",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        cols = collections.defaultdict(set)\n        rows = collections.defaultdict(set)\n        squares = collections.defaultdict(set)  # key = (r /3, c /3)\n\n        for r in range(9):\n            for c in range(9):\n                if board[r][c] == \".\":\n                    continue\n                if (\n                    board[r][c] in rows[r]\n                    or board[r][c] in cols[c]\n                    or board[r][c] in squares[(r // 3, c // 3)]\n                ):\n                    return False\n                cols[c].add(board[r][c])\n                rows[r].add(board[r][c])\n                squares[(r // 3, c // 3)].add(board[r][c])\n\n        return True",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table",
      "math"
    ],
    "approach": "\"Hash Map\""
  },
  {
    "title": "Combination Sum",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        res = []\n\n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur.copy())\n                return\n            if i >= len(candidates) or total > target:\n                return\n\n            cur.append(candidates[i])\n            dfs(i, cur, total + candidates[i])\n            cur.pop()\n            dfs(i + 1, cur, total)\n\n        dfs(0, [], 0)\n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "recursion"
    ],
    "approach": "DFS (Depth-First Search)"
  },
  {
    "title": "Combination Sum Ii",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        candidates.sort()\n\n        res = []\n\n        def backtrack(cur, pos, target):\n            if target == 0:\n                res.append(cur.copy())\n                return\n            if target <= 0:\n                return\n\n            prev = -1\n            for i in range(pos, len(candidates)):\n                if candidates[i] == prev:\n                    continue\n                cur.append(candidates[i])\n                backtrack(cur, i + 1, target - candidates[i])\n                cur.pop()\n                prev = candidates[i]\n\n        backtrack([], 0, target)\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Backtracking\"."
  },
  {
    "title": "First Missing Positive",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        A = nums\n        for i in range(len(A)):\n            if A[i] < 0:\n                A[i] = 0\n            \n        for i in range(len(A)):\n            val = abs(A[i])\n            if 1 <= val <= len(A):\n                if A[val - 1] > 0:\n                    A[val - 1] *= -1\n                elif A[val - 1] == 0:\n                    A[val - 1] = -1 * (len(A) + 1)\n        \n        for i in range( 1, len(A)+ 1):\n            if A[i -1] >= 0:\n                return i\n        \n        return len(A) + 1\n        \n    def firstMissingPositive_2(self, nums: List[int]) -> int:\n        new = set(nums)\n        i = 1\n        while i in new:\n            i += 1\n        return i",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "hash table"
    ],
    "approach": "The main algorithmic approach used is \"Hash Map\" or more specifically \"Set\"."
  },
  {
    "title": "Trapping Rain Water",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        if not height:\n            return 0\n\n        l, r = 0, len(height) - 1\n        leftMax, rightMax = height[l], height[r]\n        res = 0\n        while l < r:\n            if leftMax < rightMax:\n                l += 1\n                leftMax = max(leftMax, height[l])\n                res += leftMax - height[l]\n            else:\n                r -= 1\n                rightMax = max(rightMax, height[r])\n                res += rightMax - height[r]\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "sliding window",
      "two pointers"
    ],
    "approach": "\"Two Pointers\""
  },
  {
    "title": "Multiply Strings",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if \"0\" in [num1, num2]:\n            return \"0\"\n\n        res = [0] * (len(num1) + len(num2))\n        num1, num2 = num1[::-1], num2[::-1]\n        for i1 in range(len(num1)):\n            for i2 in range(len(num2)):\n                digit = int(num1[i1]) * int(num2[i2])\n                res[i1 + i2] += digit\n                res[i1 + i2 + 1] += res[i1 + i2] // 10\n                res[i1 + i2] = res[i1 + i2] % 10\n\n        res, beg = res[::-1], 0\n        while beg < len(res) and res[beg] == 0:\n            beg += 1\n        res = map(str, res[beg:])\n        return \"\".join(res)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "math"
    ],
    "approach": "The main algorithmic approach used is \"Dynamic Programming\"."
  },
  {
    "title": "Wildcard Matching",
    "description": "No description available.",
    "optimal_code": "class Solution(object):\n    def isMatch(self, s, p):\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        dp[-1][-1] = True\n        for i in range(len(s), -1, -1):\n            for j in range(len(p) - 1, -1, -1):\n                if p[j] == '*':\n                    dp[i][j] = dp[i][j + 1] or (i < len(s) and dp[i + 1][j])\n                else:\n                    dp[i][j] = i < len(s) and (p[j] == s[i] or p[j] == '?') and dp[i + 1][j + 1]\n        return dp[0][0]",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "array",
      "dynamic programming"
    ],
    "approach": "Dynamic Programming."
  },
  {
    "title": "Jump Game Ii",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        l, r = 0, 0\n        res = 0\n        while r < (len(nums) - 1):\n            maxJump = 0\n            for i in range(l, r + 1):\n                maxJump = max(maxJump, i + nums[i])\n            l = r + 1\n            r = maxJump\n            res += 1\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "Greedy"
  },
  {
    "title": "Permutations",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        res = []\n\n        if len(nums) == 1:\n            return [nums[:]]  # nums[:] is a deep copy\n\n        for i in range(len(nums)):\n            n = nums.pop(0)\n            perms = self.permute(nums)\n\n            for perm in perms:\n                perm.append(n)\n            res.extend(perms)\n            nums.append(n)\n        return res",
    "time_complexity": "O(log n)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "binary search"
    ],
    "approach": "Recursion."
  },
  {
    "title": "Permutations Ii",
    "description": "No description available.",
    "optimal_code": "import collections\n\n\nclass Solution:\n\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        result = []\n        counter = collections.Counter(nums)\n\n        def backtrack(perm, counter):\n            if len(perm) == len(nums):\n                result.append(perm.copy())\n\n            for n in counter:\n                if counter[n] == 0:\n                    continue\n                perm.append(n)\n                counter[n] -= 1\n                backtrack(perm, counter)\n                perm.pop()\n                counter[n] += 1\n\n        backtrack([], counter)\n\n        return result",
    "time_complexity": "O(log n)",
    "space_complexity": "O(n)",
    "tags": [
      "binary search"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Rotate Image",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        l, r = 0, len(matrix) - 1\n        while l < r:\n            for i in range(r - l):\n                top, bottom = l, r\n\n                topLeft = matrix[top][l + i]\n\n                matrix[top][l + i] = matrix[bottom - i][l]\n\n                matrix[bottom - i][l] = matrix[bottom][r - i]\n\n                matrix[bottom][r - i] = matrix[top + i][r]\n\n                matrix[top + i][r] = topLeft\n            r -= 1\n            l += 1",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "sliding window",
      "two pointers"
    ],
    "approach": "The main algorithmic approach used is \"Two Pointers\"."
  },
  {
    "title": "Group Anagrams",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        groups = {}\n\n        for s in strs: # O(m)\n            count = {}\n\n            for char in s: # O(n)\n                count[char] = count.get(char, 0) + 1\n\n            tup = tuple(sorted(count.items())) # O(1) because there is limited amount of possible keys in the alphabet -> O(26) + O(26*log26) + O(26)\n\n            if tup in groups:\n                groups[tup].append(s)\n            else:\n                groups[tup] = [s] \n            \n        return list(groups.values())\n    \n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        ans = collections.defaultdict(list)\n\n        for s in strs:\n            count = [0] * 26\n            for c in s:\n                count[ord(c) - ord(\"a\")] += 1\n            ans[tuple(count)].append(s)\n        return list(ans.values())",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "\"Hash Map\""
  },
  {
    "title": "Powx N",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        def helper(x, n):\n            if x == 0:\n                return 0\n            if n == 0:\n                return 1\n\n            res = helper(x * x, n // 2)\n            return x * res if n % 2 else res\n\n        res = helper(x, abs(n))\n        return res if n >= 0 else 1 / res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "math"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "N Queens",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        col = set()\n        posDiag = set()  # (r + c)\n        negDiag = set()  # (r - c)\n\n        res = []\n        board = [[\".\"] * n for i in range(n)]\n\n        def backtrack(r):\n            if r == n:\n                copy = [\"\".join(row) for row in board]\n                res.append(copy)\n                return\n\n            for c in range(n):\n                if c in col or (r + c) in posDiag or (r - c) in negDiag:\n                    continue\n\n                col.add(c)\n                posDiag.add(r + c)\n                negDiag.add(r - c)\n                board[r][c] = \"Q\"\n\n                backtrack(r + 1)\n\n                col.remove(c)\n                posDiag.remove(r + c)\n                negDiag.remove(r - c)\n                board[r][c] = \".\"\n\n        backtrack(0)\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "The main algorithmic approach used is: Backtracking."
  },
  {
    "title": "N Queens Ii",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        answer = 0\n\n        cols = set()\n        posdiag = set()\n        negdiag = set()\n\n        def backtrack(i):\n            if i == n:\n                nonlocal answer\n                answer += 1\n                return\n            \n            for j in range(n):\n                if j in cols or (i+j) in posdiag or (i-j) in negdiag:\n                    continue\n\n                cols.add(j)\n                posdiag.add(i+j)\n                negdiag.add(i-j)\n\n                backtrack(i+1)\n                \n                cols.remove(j)\n                posdiag.remove(i+j)\n                negdiag.remove(i-j)\n        \n        backtrack(0)\n        return answer",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Backtracking"
  },
  {
    "title": "Maximum Subarray",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        res = nums[0]\n\n        total = 0\n        for n in nums:\n            total += n\n            res = max(res, total)\n            if total < 0:\n                total = 0\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "Greedy"
  },
  {
    "title": "Spiral Matrix",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        res = []\n        left, right = 0, len(matrix[0])\n        top, bottom = 0, len(matrix)\n\n        while left < right and top < bottom:\n            for i in range(left, right):\n                res.append(matrix[top][i])\n            top += 1\n            for i in range(top, bottom):\n                res.append(matrix[i][right - 1])\n            right -= 1\n            if not (left < right and top < bottom):\n                break\n            for i in range(right - 1, left - 1, -1):\n                res.append(matrix[bottom - 1][i])\n            bottom -= 1\n            for i in range(bottom - 1, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "\"Sliding Window\""
  },
  {
    "title": "Jump Game",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        goal = len(nums) - 1\n\n        for i in range(len(nums) - 2, -1, -1):\n            if i + nums[i] >= goal:\n                goal = i\n        return goal == 0",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "array"
    ],
    "approach": "Greedy"
  },
  {
    "title": "Merge Intervals",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals.sort(key=lambda pair: pair[0])\n        output = [intervals[0]]\n\n        for start, end in intervals:\n            lastEnd = output[-1][1]\n\n            if start <= lastEnd:\n                output[-1][1] = max(lastEnd, end)\n            else:\n                output.append([start, end])\n        return output",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Sorting"
  },
  {
    "title": "Insert Interval",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def insert(\n        self, intervals: List[List[int]], newInterval: List[int]\n    ) -> List[List[int]]:\n        res = []\n\n        for i in range(len(intervals)):\n            if newInterval[1] < intervals[i][0]:\n                res.append(newInterval)\n                return res + intervals[i:]\n            elif newInterval[0] > intervals[i][1]:\n                res.append(intervals[i])\n            else:\n                newInterval = [\n                    min(newInterval[0], intervals[i][0]),\n                    max(newInterval[1], intervals[i][1]),\n                ]\n        res.append(newInterval)\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "array"
    ],
    "approach": "The main algorithmic approach used is \"Merge Interval\"."
  },
  {
    "title": "Length Of Last Word",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        \"\"\"\n\tone shortcut\n\t\"\"\"\n        count = 0\n\tfor i in range(len(s) - 1, -1, -1):\n\t\tchar = s[i]\n\t\tif char == \" \":\n\t\t\tif count >= 1:\n\t\t\t\treturn count\n\t\telse:\n\t\t\tcount += 1\n\treturn count",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "array"
    ],
    "approach": "\"From Right to Left\" or more generally \"Reverse Iteration\"."
  },
  {
    "title": "Rotate List",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next or k == 0:\n            return head\n\n        old_head = head\n\n        curr, size = head, 0\n        while curr:\n            curr, size = curr.next, size + 1\n\n        if k % size == 0:\n            return head\n\n        k %= size\n        slow = fast = head\n        while fast and fast.next:\n            if k <= 0:\n                slow = slow.next\n            fast = fast.next\n            k -= 1\n\n        new_tail, new_head, old_tail = slow, slow.next, fast\n        new_tail.next, old_tail.next = None, old_head\n\n        return new_head",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "linked list",
      "math"
    ],
    "approach": "\"Two Pointers\""
  },
  {
    "title": "Unique Paths",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        row = [1] * n\n\n        for i in range(m - 1):\n            newRow = [1] * n\n            for j in range(n - 2, -1, -1):\n                newRow[j] = newRow[j + 1] + row[j]\n            row = newRow\n        return row[0]",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Unique Paths Ii",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\n        M, N = len(grid), len(grid[0])\n        dp = [0] * N\n        dp[N-1] = 1\n\n        for r in reversed(range(M)):\n            for c in reversed(range(N)):\n                if grid[r][c]:\n                    dp[c] = 0\n                elif c + 1 < N:\n                    dp[c] = dp[c] + dp[c + 1]\n        return dp[0]\n\n\n        M, N = len(grid), len(grid[0])\n        dp = {(M - 1, N - 1): 1}\n\n        def dfs(r, c):\n            if r == M or c == N or grid[r][c]:\n                return 0\n            if (r, c) in dp:\n                return dp[(r, c)]\n            dp[(r, c)] = dfs(r + 1, c) + dfs(r, c + 1)\n            return dp[(r, c)]\n        return dfs(0, 0)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "dfs",
      "dynamic programming",
      "recursion"
    ],
    "approach": "The main algorithmic approach used is \"Dynamic Programming\"."
  },
  {
    "title": "Minimum Path Sum",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        prev = [float(\"inf\")] * n\n        prev[-1] = 0\n\n        for row in range(m - 1, -1, -1):\n            dp = [float(\"inf\")] * n\n            for col in range(n - 1, -1, -1):\n                if col < n - 1:\n                    dp[col] = min(dp[col], dp[col + 1])\n                dp[col] = min(dp[col], prev[col]) + grid[row][col]\n            prev = dp\n\n        return prev[0]",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "dynamic programming"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Plus One",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        one = 1\n        i = 0\n        digits = digits[::-1]\n\n        while one:\n            if i < len(digits):\n                if digits[i] == 9:\n                    digits[i] = 0\n                else:\n                    digits[i] += 1\n                    one = 0\n            else:\n                digits.append(one)\n                one = 0\n            i += 1\n        return digits[::-1]",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used here is \"Iteration\"."
  },
  {
    "title": "Add Binary",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        res = \"\"\n        carry = 0\n\n        a, b = a[::-1], b[::-1]\n        for i in range(max(len(a), len(b))):\n            bitA = ord(a[i]) - ord('0') if i < len(a) else 0\n            bitB = ord(b[i]) - ord('0') if i < len(b) else 0\n\n            total = bitA + bitB + carry\n            char = str(total % 2)\n            res = char + res\n            carry = total // 2\n\n        if carry:\n            res = \"1\" + res\n\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "math"
    ],
    "approach": "The main algorithmic approach used is: **Iterative** (combined with some basic arithmetic and string manipulation)."
  },
  {
    "title": "Text Justification",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        res = []\n        line = []  # Words in current line\n        length = 0  # Current line length\n        i = 0\n        while i < len(words):\n            if length + len(line) + len(words[i]) > maxWidth:\n                extra_space = maxWidth - length\n                word_cnt = len(line) - 1\n                spaces = extra_space // max(1, word_cnt)\n                remainder = extra_space % max(1, word_cnt)\n\n                for j in range(max(1, len(line) - 1)):\n                    line[j] += \" \" * spaces\n                    if remainder:\n                        line[j] += \" \"\n                        remainder -= 1\n\n                res.append(\"\".join(line))\n                line, length = [], 0  # Reset line and length\n            \n            line.append(words[i])\n            length += len(words[i])\n            i += 1\n\n        last_line = \" \".join(line)\n        trail_spaces = maxWidth - len(last_line)\n        res.append(last_line + (trail_spaces * \" \"))\n\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table",
      "math"
    ],
    "approach": "The main algorithmic approach used is \"Dynamic Programming\"."
  },
  {
    "title": "Sqrtx",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        l, r = 0, x\n        while l <= r:\n            mid = (l + r) // 2\n            if mid * mid == x:\n                return mid\n            if mid * mid < x:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return r",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "Binary Search"
  },
  {
    "title": "Climbing Stairs",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        if n <= 3:\n            return n\n        n1, n2 = 2, 3\n\n        for i in range(4, n + 1):\n            temp = n1 + n2\n            n1 = n2\n            n2 = temp\n        return n2",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Simplify Path",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n\n        stack = []\n\n        for i in path.split(\"/\"):\n\n            if i == \"..\":\n                if stack:\n                    stack.pop()\n            elif i == \".\" or i == '':\n                continue\n            else:\n                stack.append(i)\n\n        res = \"/\" + \"/\".join(stack)\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "The main algorithmic approach used is: \"Stack\""
  },
  {
    "title": "Edit Distance",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        dp = [[float(\"inf\")] * (len(word2) + 1) for i in range(len(word1) + 1)]\n\n        for j in range(len(word2) + 1):\n            dp[len(word1)][j] = len(word2) - j\n        for i in range(len(word1) + 1):\n            dp[i][len(word2)] = len(word1) - i\n\n        for i in range(len(word1) - 1, -1, -1):\n            for j in range(len(word2) - 1, -1, -1):\n                if word1[i] == word2[j]:\n                    dp[i][j] = dp[i + 1][j + 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j + 1], dp[i + 1][j + 1])\n        return dp[0][0]",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "array",
      "dynamic programming"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Set Matrix Zeroes",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        rowZero = False\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if matrix[r][c] == 0:\n                    matrix[0][c] = 0\n                    if r > 0:\n                        matrix[r][0] = 0\n                    else:\n                        rowZero = True\n\n        for r in range(1, ROWS):\n            for c in range(1, COLS):\n                if matrix[0][c] == 0 or matrix[r][0] == 0:\n                    matrix[r][c] = 0\n\n        if matrix[0][0] == 0:\n            for r in range(ROWS):\n                matrix[r][0] = 0\n\n        if rowZero:\n            for c in range(COLS):\n                matrix[0][c] = 0",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "The main algorithmic approach used is \"Two Pointers\"."
  },
  {
    "title": "Search A 2D Matrix",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        ROWS, COLS = len(matrix), len(matrix[0])\n\n        top, bot = 0, ROWS - 1\n        while top <= bot:\n            row = (top + bot) // 2\n            if target > matrix[row][-1]:\n                top = row + 1\n            elif target < matrix[row][0]:\n                bot = row - 1\n            else:\n                break\n\n        if not (top <= bot):\n            return False\n        row = (top + bot) // 2\n        l, r = 0, COLS - 1\n        while l <= r:\n            m = (l + r) // 2\n            if target > matrix[row][m]:\n                l = m + 1\n            elif target < matrix[row][m]:\n                r = m - 1\n            else:\n                return True\n        return False",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "Binary Search"
  },
  {
    "title": "Sort Colors",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        low = 0\n        high = len(nums) - 1\n        mid = 0\n\n        while mid <= high:\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n            elif nums[mid] == 1:\n                mid +=1\n            else:\n                nums[mid], nums[high] = nums[high], nums[mid]\n                high -= 1\n        return nums",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "\"Two Pointers\""
  },
  {
    "title": "Minimum Window Substring",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if len(s) < len(t):\n            return \"\"\n\n        countT, window = {}, {}\n        for c in t:\n            countT[c] = 1 + countT.get(c, 0)\n\n        have, need = 0, len(countT)\n        res, resLen = [-1, -1], float(\"infinity\")\n        l = 0\n        for r in range(len(s)):\n            c = s[r]\n            window[c] = 1 + window.get(c, 0)\n\n            if c in countT and window[c] == countT[c]:\n                have += 1\n\n            while have == need:\n                if (r - l + 1) < resLen:\n                    res = [l, r]\n                    resLen = r - l + 1\n                window[s[l]] -= 1\n                if s[l] in countT and window[s[l]] < countT[s[l]]:\n                    have -= 1\n                l += 1\n        l, r = res\n        return s[l : r + 1] if resLen != float(\"infinity\") else \"\"",
    "time_complexity": "O(log n)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "binary search",
      "hash table"
    ],
    "approach": "The main algorithmic approach used is \"Sliding Window\"."
  },
  {
    "title": "Combinations",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        res = []\n        def helper(start, comb):\n            if len(comb) == k:\n                res.append(comb.copy())\n                return\n            for i in range(start, n+1):\n                comb.append(i)\n                helper(i+1, comb)\n                comb.pop()\n        helper(1, [])\n        return res",
    "time_complexity": "O(log n)",
    "space_complexity": "O(n)",
    "tags": [
      "binary search"
    ],
    "approach": "The main algorithmic approach used is \"Recursion\"."
  },
  {
    "title": "Subsets",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        res = []\n\n        subset = []\n\n        def dfs(i):\n            if i >= len(nums):\n                res.append(subset.copy())\n                return\n            subset.append(nums[i])\n            dfs(i + 1)\n            subset.pop()\n            dfs(i + 1)\n\n        dfs(0)\n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "hash table",
      "recursion"
    ],
    "approach": "DFS (Depth-First Search)"
  },
  {
    "title": "Word Search",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        ROWS, COLS = len(board), len(board[0])\n        path = set()\n\n        def dfs(r, c, i):\n            if i == len(word):\n                return True\n            if (\n                min(r, c) < 0\n                or r >= ROWS\n                or c >= COLS\n                or word[i] != board[r][c]\n                or (r, c) in path\n            ):\n                return False\n            path.add((r, c))\n            res = (\n                dfs(r + 1, c, i + 1)\n                or dfs(r - 1, c, i + 1)\n                or dfs(r, c + 1, i + 1)\n                or dfs(r, c - 1, i + 1)\n            )\n            path.remove((r, c))\n            return res\n\n        count = sum(map(Counter, board), Counter())\n        if count[word[0]] > count[word[-1]]:\n            word = word[::-1]\n            \n        for r in range(ROWS):\n            for c in range(COLS):\n                if dfs(r, c, 0):\n                    return True\n        return False",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "hash table",
      "recursion"
    ],
    "approach": "Depth-First Search (DFS)"
  },
  {
    "title": "Remove Duplicates From Sorted Array Ii",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        l, r = 0, 0\n\n        while r < len(nums):\n            count = 1\n            while r + 1 < len(nums) and nums[r] == nums[r + 1]:\n                r += 1\n                count += 1\n            \n            for i in range(min(2, count)):\n                nums[l] = nums[r]\n                l += 1\n            r += 1\n        return l",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Two Pointers"
  },
  {
    "title": "Search In Rotated Sorted Array Ii",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        left,right = 0,len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return True\n\n            if nums[left] < nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            elif nums[left] > nums[mid]:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            else:\n                left += 1\n        return False",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "Binary Search"
  },
  {
    "title": "Remove Duplicates From Sorted List",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        cur = head\n        while cur:\n            while cur.next and cur.next.val == cur.val:\n                cur.next = cur.next.next\n            cur = cur.next\n        return head",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "linked list"
    ],
    "approach": "\"Two Pointers\""
  },
  {
    "title": "Largest Rectangle In Histogram",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        maxArea = 0\n        stack = []  # pair: (index, height)\n\n        for i, h in enumerate(heights):\n            start = i\n            while stack and stack[-1][1] > h:\n                index, height = stack.pop()\n                maxArea = max(maxArea, height * (i - index))\n                start = index\n            stack.append((start, h))\n\n        for i, h in stack:\n            maxArea = max(maxArea, h * (len(heights) - i))\n        return maxArea",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Stack\" with a hint of \"Greedy\"."
  },
  {
    "title": "Partition List",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\n        less_head, bigger_head = ListNode(-1), ListNode(-1)\n        less_prev, bigger_prev = less_head, bigger_head\n        while head:\n            if head.val < x:\n                less_prev.next = head\n                less_prev = less_prev.next\n            else:\n                bigger_prev.next = head\n                bigger_prev = bigger_prev.next\n\n            head = head.next\n\n        less_prev.next = bigger_prev.next = None\n        less_prev.next = bigger_head.next\n\n        return less_head.next",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "linked list"
    ],
    "approach": "\"Two Pointers\""
  },
  {
    "title": "Merge Sorted Array",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        while m > 0 and n > 0:\n            if nums1[m-1] >= nums2[n-1]:\n                nums1[m+n-1] = nums1[m-1]\n                m -= 1\n            else:\n                nums1[m+n-1] = nums2[n-1]\n                n -= 1\n        if n > 0:\n            nums1[:n] = nums2[:n]",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Two Pointers"
  },
  {
    "title": "Subsets Ii",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        nums.sort()\n\n        def backtrack(i, subset):\n            if i == len(nums):\n                res.append(subset[::])\n                return\n\n            subset.append(nums[i])\n            backtrack(i + 1, subset)\n            subset.pop()\n            while i + 1 < len(nums) and nums[i] == nums[i + 1]:\n                i += 1\n            backtrack(i + 1, subset)\n\n        backtrack(0, [])\n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "\"Backtracking\""
  },
  {
    "title": "Decode Ways",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        dp = {len(s): 1}\n\n        def dfs(i):\n            if i in dp:\n                return dp[i]\n            if s[i] == \"0\":\n                return 0\n\n            res = dfs(i + 1)\n            if i + 1 < len(s) and (\n                s[i] == \"1\" or s[i] == \"2\" and s[i + 1] in \"0123456\"\n            ):\n                res += dfs(i + 2)\n            dp[i] = res\n            return res\n\n        return dfs(0)\n\n        dp = {len(s): 1}\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == \"0\":\n                dp[i] = 0\n            else:\n                dp[i] = dp[i + 1]\n\n            if i + 1 < len(s) and (\n                s[i] == \"1\" or s[i] == \"2\" and s[i + 1] in \"0123456\"\n            ):\n                dp[i] += dp[i + 2]\n        return dp[0]",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "dfs",
      "dynamic programming",
      "recursion"
    ],
    "approach": "Dynamic Programming (DP)"
  },
  {
    "title": "Reverse Linked List Ii",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def reverseBetween(\n        self, head: Optional[ListNode], left: int, right: int\n    ) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n\n        leftPrev, cur = dummy, head\n        for i in range(left - 1):\n            leftPrev, cur = cur, cur.next\n\n        prev = None\n        for i in range(right - left + 1):\n            tmpNext = cur.next\n            cur.next = prev\n            prev, cur = cur, tmpNext\n\n        leftPrev.next.next = cur  # cur is node after \"right\"\n        leftPrev.next = prev  # prev is \"right\"\n        return dummy.next",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "linked list"
    ],
    "approach": "\"Pointers\""
  },
  {
    "title": "Binary Tree Inorder Traversal",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        res, stack = [], []\n        cur = root\n\n        while cur or stack:\n            while cur:\n                stack.append(cur)\n                cur = cur.left\n            cur = stack.pop()\n            res.append(cur.val)\n            cur = cur.right\n        return res\n\n        res = []\n\n        def helper(root):\n            if not root:\n                return\n            helper(root.left)\n            res.append(root.val)\n            helper(root.right)\n\n        helper(root)\n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "tree"
    ],
    "approach": "The main algorithmic approach used is \"Stack\"."
  },
  {
    "title": "Interleaving String",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3):\n            return False\n\n        dp = [[False] * (len(s2) + 1) for i in range(len(s1) + 1)]\n        dp[len(s1)][len(s2)] = True\n\n        for i in range(len(s1), -1, -1):\n            for j in range(len(s2), -1, -1):\n                if i < len(s1) and s1[i] == s3[i + j] and dp[i + 1][j]:\n                    dp[i][j] = True\n                if j < len(s2) and s2[j] == s3[i + j] and dp[i][j + 1]:\n                    dp[i][j] = True\n        return dp[0][0]",
    "time_complexity": "O(log n)",
    "space_complexity": "O(1)",
    "tags": [
      "array",
      "binary search",
      "dynamic programming"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Validate Binary Search Tree",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isValidBST(self, root: TreeNode) -> bool:\n        def valid(node, left, right):\n            if not node:\n                return True\n            if not (left < node.val < right):\n                return False\n\n            return valid(node.left, left, node.val) and valid(\n                node.right, node.val, right\n            )\n\n        return valid(root, float(\"-inf\"), float(\"inf\"))",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "tree"
    ],
    "approach": "\"Recursion\""
  },
  {
    "title": "Same Tree",
    "description": "No description available.",
    "optimal_code": "\n\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if p and q and p.val == q.val:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n        else:\n            return False",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "tree"
    ],
    "approach": "Recursive Depth-First Search (DFS)."
  },
  {
    "title": "Symmetric Tree",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\n        if not root.left and not root.right:\n            return True\n        queueLeft = deque()\n        queueRight = deque()\n\n        queueLeft.appendleft(root.left)\n        queueRight.appendleft(root.right)\n\n        while queueLeft and queueRight:\n            nodeLeft, nodeRight = queueLeft.pop(), queueRight.pop()\n            if not nodeLeft and not nodeRight:\n                continue\n            if not nodeLeft or not nodeRight or nodeLeft.val != nodeRight.val:\n                return False\n\n            queueLeft.appendleft(nodeLeft.left)\n            queueLeft.appendleft(nodeLeft.right)\n\n            queueRight.appendleft(nodeRight.right)\n            queueRight.appendleft(nodeRight.left)\n        return not (queueLeft or queueRight)",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "tree"
    ],
    "approach": "The main algorithmic approach used is \"Queue-based BFS\"."
  },
  {
    "title": "Binary Tree Level Order Traversal",
    "description": "No description available.",
    "optimal_code": "\n\nclass Solution:\n    def levelOrder(self, root: TreeNode) -> List[List[int]]:\n        res = []\n        q = collections.deque()\n        if root:\n            q.append(root)\n\n        while q:\n            val = []\n\n            for i in range(len(q)):\n                node = q.popleft()\n                val.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(val)\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "tree"
    ],
    "approach": "\"BFS\" (Breadth-First Search)"
  },
  {
    "title": "Binary Tree Zigzag Level Order Traversal",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if root is None:\n            return\n        result, zigzagDirection = [], 1\n        q = [root]\n        while q:\n            level, queueLength = [], len(q)\n            for i in range(queueLength):\n                node = q.pop(0)\n                level.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            result.append(level[::zigzagDirection])\n            zigzagDirection *= -1\n        return result",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "tree"
    ],
    "approach": "\"Breadth-First Search\" (BFS)"
  },
  {
    "title": "Maximum Depth Of Binary Tree",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n\n\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        stack = [[root, 1]]\n        res = 0\n\n        while stack:\n            node, depth = stack.pop()\n\n            if node:\n                res = max(res, depth)\n                stack.append([node.left, depth + 1])\n                stack.append([node.right, depth + 1])\n        return res\n\n\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        q = deque()\n        if root:\n            q.append(root)\n\n        level = 0\n\n        while q:\n\n            for i in range(len(q)):\n                node = q.popleft()\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            level += 1\n        return level",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "tree"
    ],
    "approach": "The main algorithmic approach used is **Recursive** (or **Depth-First Search**, depending on the interpretation)."
  },
  {
    "title": "Construct Binary Tree From Preorder And Inorder Traversal",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        if not preorder or not inorder:\n            return None\n\n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1 : mid + 1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid + 1 :], inorder[mid + 1 :])\n        return root",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "tree"
    ],
    "approach": "Recursion."
  },
  {
    "title": "Construct Binary Tree From Inorder And Postorder Traversal",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        def buildTreeHelper(left, right):\n            if left > right:\n                return None\n\n            rootVal = postorder.pop()\n            rootNode = TreeNode(rootVal)\n\n            idx = inorderIndexMap[rootVal]\n            rootNode.right = buildTreeHelper(idx + 1, right)\n            rootNode.left = buildTreeHelper(left, idx - 1)\n            return rootNode\n\n        inorderIndexMap = {}\n        for (i, val) in enumerate(inorder):\n            inorderIndexMap[val] = i\n\n        return buildTreeHelper(0, len(postorder) - 1)",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table",
      "tree"
    ],
    "approach": "The main algorithmic approach used is \"Recursion\"."
  },
  {
    "title": "Convert Sorted Array To Binary Search Tree",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:\n        if not nums:\n            return None\n        mid = len(nums)//2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        return root",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "math",
      "tree"
    ],
    "approach": "Recursive DFS."
  },
  {
    "title": "Balanced Binary Tree",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        def dfs(root):\n            if not root:\n                return [True, 0]\n\n            left, right = dfs(root.left), dfs(root.right)\n            balanced = left[0] and right[0] and abs(left[1] - right[1]) <= 1\n            return [balanced, 1 + max(left[1], right[1])]\n\n        return dfs(root)[0]",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "dfs",
      "recursion",
      "tree"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Path Sum",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def hasPathSum(self, root, sum):\n        if not root:\n            return False\n        sum -= root.val\n        if not root.left and not root.right:\n            return sum == 0\n        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\n      \nclass Solution:\n    def hasPathSum(self, root, sum):\n        de = [\n            (root, sum - root.val),\n        ]\n        while de:\n            node, curr_sum = de.pop()\n            if not node.left and not node.right and curr_sum == 0:\n                return True\n            if node.right:\n                de.append((node.right, curr_sum - node.right.val))\n            if node.left:\n                de.append((node.left, curr_sum - node.left.val))\n        return False",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Recursive DFS."
  },
  {
    "title": "Distinct Subsequences",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        cache = {}\n\n        for i in range(len(s) + 1):\n            cache[(i, len(t))] = 1\n        for j in range(len(t)):\n            cache[(len(s), j)] = 0\n\n        for i in range(len(s) - 1, -1, -1):\n            for j in range(len(t) - 1, -1, -1):\n                if s[i] == t[j]:\n                    cache[(i, j)] = cache[(i + 1, j + 1)] + cache[(i + 1, j)]\n                else:\n                    cache[(i, j)] = cache[(i + 1, j)]\n        return cache[(0, 0)]",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "hash table"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Pascals Triangle",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def generate(self, rowIndex) -> List[List[int]]:\n        if rowIndex == 0:\n            return [[1]]\n        else:\n            return self.getAllRow(rowIndex - 1)\n\n    def getAllRow(self, rowIndex):\n        if rowIndex == 0:\n            return [[1]]\n        ListPrec = self.getAllRow(rowIndex - 1)\n        Len = len(ListPrec[-1])\n        ListPrec.append([1])\n        for i in range(0, Len - 1):\n            ListPrec[-1].append(ListPrec[-2][i] + ListPrec[-2][i + 1])\n        ListPrec[-1].append(1)\n        return ListPrec",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Pascal Triangle Ii",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    Memo = {}\n\n    def getRow(self, rowIndex: int) -> List[int]:\n        if rowIndex in self.Memo:\n            return self.Memo[rowIndex]\n        if rowIndex == 0:\n            return [1]\n        ListPrec = self.getRow(rowIndex - 1)\n        Result = [1]\n        for i in range(0, len(ListPrec) - 1):\n            Result.append(ListPrec[i] + ListPrec[i + 1])\n        Result.append(1)\n        self.Memo[rowIndex] = Result\n        return Result",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Triangle",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        dp = triangle[-1]\n\n        for row in range(len(triangle) - 2, -1, -1):\n            for col in range(0, row + 1):\n                dp[col] = triangle[row][col] + min(dp[col], dp[col + 1])\n\n        return dp[0]",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "array",
      "dynamic programming"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Best Time To Buy And Sell Stock",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        res = 0\n        \n        lowest = prices[0]\n        for price in prices:\n            if price < lowest:\n                lowest = price\n            res = max(res, price - lowest)\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "Greedy"
  },
  {
    "title": "Best Time To Buy And Sell Stock Ii",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        max_profit = 0\n        for i in range(1, len(prices)):\n            if prices[i] > prices[i-1]:\n                max_profit += prices[i] - prices[i-1]\n        return max_profit",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "One Pass/Single Pass"
  },
  {
    "title": "Binary Tree Maximum Path Sum",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxPathSum(self, root: TreeNode) -> int:\n        res = [root.val]\n\n        def dfs(root):\n            if not root:\n                return 0\n\n            leftMax = dfs(root.left)\n            rightMax = dfs(root.right)\n            leftMax = max(leftMax, 0)\n            rightMax = max(rightMax, 0)\n\n            res[0] = max(res[0], root.val + leftMax + rightMax)\n            return root.val + max(leftMax, rightMax)\n\n        dfs(root)\n        return res[0]",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "recursion",
      "tree"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Valid Palindrome",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        new = ''\n        for a in s:\n            if a.isalpha() or a.isdigit():\n                new += a.lower()\n        return (new == new[::-1])",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used here is \"String Manipulation\" which involves iterating through the string and performing some operations on it, in this case, creating a new string with only alphanumeric characters and checking if that string is the same when reversed, hence a palindrome. However, since you asked for common terms like DFS/BFS etc., I would say the main approach used here is \"Greedy\" as it processes the input one by one from left to right without looking ahead."
  },
  {
    "title": "Word Ladder",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n\n        nei = collections.defaultdict(list)\n        wordList.append(beginWord)\n        for word in wordList:\n            for j in range(len(word)):\n                pattern = word[:j] + \"*\" + word[j + 1 :]\n                nei[pattern].append(word)\n\n        visit = set([beginWord])\n        q = deque([beginWord])\n        res = 1\n        while q:\n            for i in range(len(q)):\n                word = q.popleft()\n                if word == endWord:\n                    return res\n                for j in range(len(word)):\n                    pattern = word[:j] + \"*\" + word[j + 1 :]\n                    for neiWord in nei[pattern]:\n                        if neiWord not in visit:\n                            visit.add(neiWord)\n                            q.append(neiWord)\n            res += 1\n        return 0",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "hash table"
    ],
    "approach": "\"Breadth-First Search\" (BFS) with a twist of using \"Hash Map\" to store the neighbors of each word."
  },
  {
    "title": "Longest Consecutive Sequence",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        numSet = set(nums)\n        longest = 0\n\n        for n in numSet:\n            if (n - 1) not in numSet:\n                length = 1\n                while (n + length) in numSet:\n                    length += 1\n                longest = max(length, longest)\n        return longest",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "\"Hash Map\", \"Greedy\" and \"Sliding Window\" (although not strictly a sliding window problem)."
  },
  {
    "title": "Surrounded Regions",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        rows, cols = len(board), len(board[0])\n        flag = set()\n\n        def dfs(r, c):\n            if not(r in range(rows) and c in range(cols)) or board[r][c] != 'O' or (r, c) in flag:\n                return\n            flag.add((r, c))\n            return (dfs(r + 1, c), dfs(r - 1, c), dfs(r, c + 1), dfs(r, c - 1))\n\n        for r in range(rows):\n            for c in range(cols):\n                if( (r == 0 or c == 0 or r == rows - 1 or c == cols - 1) and board[r][c] == 'O'):\n                    dfs(r, c)\n\n        for r in range(rows):\n            for c in range(cols):\n                if board[r][c] == 'O' and (r, c) not in flag:\n                    board[r][c] = 'X'\n\n    '''\n    def solve(self, board: List[List[str]]) -> None:\n        ROWS, COLS = len(board), len(board[0])\n\n        def capture(r, c):\n            if r < 0 or c < 0 or r == ROWS or c == COLS or board[r][c] != \"O\":\n                return\n            board[r][c] = \"T\"\n            capture(r + 1, c)\n            capture(r - 1, c)\n            capture(r, c + 1)\n            capture(r, c - 1)\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if board[r][c] == \"O\" and (r in [0, ROWS - 1] or c in [0, COLS - 1]):\n                    capture(r, c)\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if board[r][c] == \"O\":\n                    board[r][c] = \"X\"\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if board[r][c] == \"T\":\n                    board[r][c] = \"O\"\n    '''",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "hash table",
      "recursion"
    ],
    "approach": "The main algorithmic approach used is **Depth-First Search (DFS)**."
  },
  {
    "title": "Palindrome Partitioning",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        res, part = [], []\n\n        def dfs(i):\n            if i >= len(s):\n                res.append(part.copy())\n                return\n            for j in range(i, len(s)):\n                if self.isPali(s, i, j):\n                    part.append(s[i : j + 1])\n                    dfs(j + 1)\n                    part.pop()\n\n        dfs(0)\n        return res\n\n    def isPali(self, s, l, r):\n        while l < r:\n            if s[l] != s[r]:\n                return False\n            l, r = l + 1, r - 1\n        return True",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "dfs",
      "recursion",
      "sliding window",
      "two pointers"
    ],
    "approach": "\"Depth-First Search (DFS)\""
  },
  {
    "title": "Clone Graph",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def cloneGraph(self, node: \"Node\") -> \"Node\":\n        oldToNew = {}\n\n        def dfs(node):\n            if node in oldToNew:\n                return oldToNew[node]\n\n            copy = Node(node.val)\n            oldToNew[node] = copy\n            for nei in node.neighbors:\n                copy.neighbors.append(dfs(nei))\n            return copy\n\n        return dfs(node) if node else None",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "hash table",
      "recursion"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Gas Station",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        start, end = len(gas) - 1, 0\n        total = gas[start] - cost[start]\n\n        while start >= end:\n            while total < 0 and start >= end:\n                start -= 1\n                total += gas[start] - cost[start]\n            if start == end:\n                return start\n            total += gas[end] - cost[end]\n            end += 1\n        return -1",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "\"Greedy\""
  },
  {
    "title": "Candy",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1] * n \n\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "\"Two Pointers\" and \"Greedy\"."
  },
  {
    "title": "Single Number",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        res = 0\n        for n in nums:\n            res = n ^ res\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "XOR (Greedy)"
  },
  {
    "title": "Copy List With Random Pointer",
    "description": "No description available.",
    "optimal_code": "\"\"\"\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\n\nclass Solution:\n    def copyRandomList(self, head: \"Node\") -> \"Node\":\n        oldToCopy = {None: None}\n\n        cur = head\n        while cur:\n            copy = Node(cur.val)\n            oldToCopy[cur] = copy\n            cur = cur.next\n        cur = head\n        while cur:\n            copy = oldToCopy[cur]\n            copy.next = oldToCopy[cur.next]\n            copy.random = oldToCopy[cur.random]\n            cur = cur.next\n        return oldToCopy[head]",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Hash Map"
  },
  {
    "title": "Word Break",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n\n        dp = [False] * (len(s) + 1)\n        dp[len(s)] = True\n\n        for i in range(len(s) - 1, -1, -1):\n            for w in wordDict:\n                if (i + len(w)) <= len(s) and s[i : i + len(w)] == w:\n                    dp[i] = dp[i + len(w)]\n                if dp[i]:\n                    break\n\n        return dp[0]",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "dynamic programming",
      "hash table"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Linked List Cycle",
    "description": "No description available.",
    "optimal_code": "\n\nclass Solution:\n    def hasCycle(self, head: ListNode) -> bool:\n        slow, fast = head, head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True\n        return False",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "linked list"
    ],
    "approach": "\"Two Pointers\""
  },
  {
    "title": "Reorder List",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def reorderList(self, head: ListNode) -> None:\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        second = slow.next\n        prev = slow.next = None\n        while second:\n            tmp = second.next\n            second.next = prev\n            prev = second\n            second = tmp\n\n        first, second = head, prev\n        while second:\n            tmp1, tmp2 = first.next, second.next\n            first.next = second\n            second.next = tmp1\n            first, second = tmp1, tmp2",
    "time_complexity": "Unknown",
    "space_complexity": "Unknown",
    "tags": [
      "linked list"
    ],
    "approach": "\"Reversing a Linked List\" and \"Merging two sorted lists\" (which can be done with a Two Pointers algorithm)."
  },
  {
    "title": "Binary Tree Preorder Traversal",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        cur, stack = root, []\n        res = []\n        while cur or stack:\n            if cur:\n                res.append(cur.val)\n                stack.append(cur.right)\n                cur = cur.left\n            else:\n                cur = stack.pop()\n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "tree"
    ],
    "approach": "\"Stack-Based\" or more specifically, \"Iterative Preorder Traversal\"."
  },
  {
    "title": "Binary Tree Postorder Traversal",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        stack = [root]\n        visit = [False]\n        res = []\n\n        while stack:\n            cur, v = stack.pop(), visit.pop()\n            if cur:\n                if v:\n                    res.append(cur.val)\n                else:\n                    stack.append(cur)\n                    visit.append(True)\n                    stack.append(cur.right)\n                    visit.append(False)\n                    stack.append(cur.left)\n                    visit.append(False)\n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "tree"
    ],
    "approach": "The main algorithmic approach used is \"Two Pointers\" (or more specifically, a variation of this technique)."
  },
  {
    "title": "Lru Cache",
    "description": "No description available.",
    "optimal_code": "class Node:\n    def __init__(self, key, val):\n        self.key, self.val = key, val\n        self.prev = self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}  # map key to node\n\n        self.left, self.right = Node(0, 0), Node(0, 0)\n        self.left.next, self.right.prev = self.right, self.left\n\n    def remove(self, node):\n        prev, nxt = node.prev, node.next\n        prev.next, nxt.prev = nxt, prev\n\n    def insert(self, node):\n        prev, nxt = self.right.prev, self.right\n        prev.next = nxt.prev = node\n        node.next, node.prev = nxt, prev\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            self.remove(self.cache[key])\n            self.insert(self.cache[key])\n            return self.cache[key].val\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.remove(self.cache[key])\n        self.cache[key] = Node(key, value)\n        self.insert(self.cache[key])\n\n        if len(self.cache) > self.cap:\n            lru = self.left.next\n            self.remove(lru)\n            del self.cache[lru.key]",
    "time_complexity": "O(log n)",
    "space_complexity": "O(n)",
    "tags": [
      "binary search",
      "hash table"
    ],
    "approach": "Linked List"
  },
  {
    "title": "Insertion Sort List",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        sentinel = ListNode()\n        curr = head\n        while curr:\n            prev = sentinel\n            while prev.next and curr.val >= prev.next.val:\n                prev = prev.next\n\n            curr.next, prev.next, curr = prev.next, curr, curr.next\n\n        return sentinel.next",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "linked list"
    ],
    "approach": "\"Insertion Sort\""
  },
  {
    "title": "Sort List",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        mid = self.get_mid(head)\n        left, right = self.sortList(head), self.sortList(mid)\n\n        return self.merge_two_sorted(left, right)\n\n\n    def merge_two_sorted(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        if not list1:\n            return list2\n\n        if not list2:\n            return list1\n\n        sentinel = ListNode()\n        prev = sentinel\n        while list1 and list2:\n            if list1.val < list2.val:\n                prev.next = list1\n                list1 = list1.next\n            else:\n                prev.next = list2\n                list2 = list2.next\n            prev = prev.next\n\n        if list1:\n            prev.next = list1\n        else:\n            prev.next = list2\n\n        return sentinel.next\n\n\n    def get_mid(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        mid_prev = None\n        while head and head.next:\n            mid_prev = mid_prev.next if mid_prev else head\n            head = head.next.next\n\n        mid = mid_prev.next\n        mid_prev.next = None\n\n        return mid",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "linked list"
    ],
    "approach": "Divide and Conquer with Recursive Splitting."
  },
  {
    "title": "Max Points On A Line",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n\n        res = 1\n        for i in range(len(points)):\n            p1 = points[i]\n            count = collections.defaultdict(int)\n            for j in range(i + 1, len(points)):\n                p2 = points[j]\n                if p2[0] == p1[0]:\n                    slope = float(\"inf\")\n                else:\n                    slope = (p2[1] - p1[1]) / (p2[0] - p1[0])\n                count[slope] += 1\n                res = max(res, count[slope] + 1)\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "hash table"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Evaluate Reverse Polish Notation",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        stack = []\n        for c in tokens:\n            if c == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif c == \"-\":\n                a, b = stack.pop(), stack.pop()\n                stack.append(b - a)\n            elif c == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif c == \"/\":\n                a, b = stack.pop(), stack.pop()\n                stack.append(int(float(b) / a))\n            else:\n                stack.append(int(c))\n        return stack[0]",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Stack-based parsing (similar to Shunting-yard algorithm)."
  },
  {
    "title": "Reverse Words In A String",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def reverseWords(self, s: str) -> str:\n        s = s.strip()\n        \n        words = s.split()\n        \n        words = words[::-1]\n        \n        reversed_str = ' '.join(words)\n        \n        return reversed_str",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"String Manipulation\"."
  },
  {
    "title": "Maximum Product Subarray",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        res = nums[0]\n        curMin, curMax = 1, 1\n\n        for n in nums:\n\n            tmp = curMax * n\n            curMax = max(n * curMax, n * curMin, n)\n            curMin = min(tmp, n * curMin, n)\n            res = max(res, curMax)\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Find Minimum In Rotated Sorted Array",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        start , end = 0, len(nums) - 1 \n        curr_min = float(\"inf\")\n        \n        while start  <  end :\n            mid = start + (end - start ) // 2\n            curr_min = min(curr_min,nums[mid])\n            \n            if nums[mid] > nums[end]:\n                start = mid + 1\n                \n            else:\n                end = mid - 1 \n                \n        return min(curr_min,nums[start])",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "Binary Search"
  },
  {
    "title": "Min Stack",
    "description": "No description available.",
    "optimal_code": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n\n    def pop(self) -> None:\n        self.stack.pop()\n        self.minStack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def getMin(self) -> int:\n        return self.minStack[-1]",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Intersection Of Two Linked Lists",
    "description": "No description available.",
    "optimal_code": "\n\nclass Solution:\n    def getIntersectionNode(\n        self, headA: ListNode, headB: ListNode\n    ) -> Optional[ListNode]:\n        l1, l2 = headA, headB\n        while l1 != l2:\n            l1 = l1.next if l1 else headB\n            l2 = l2.next if l2 else headA\n        return l1",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "linked list"
    ],
    "approach": "\"Two Pointers\""
  },
  {
    "title": "Find Peak Element",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (r + l) // 2\n            if mid < len(nums) - 1 and nums[mid] < nums[mid+1]:\n                l = mid + 1\n            elif mid > 0 and nums[mid] < nums[mid-1]:\n                r = mid - 1\n            else:\n                break\n        return mid",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "dynamic programming",
      "math"
    ],
    "approach": "Binary Search"
  },
  {
    "title": "Two Sum Ii Input Array Is Sorted",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        l, r = 0, len(numbers) - 1\n\n        while l < r:\n            curSum = numbers[l] + numbers[r]\n\n            if curSum > target:\n                r -= 1\n            elif curSum < target:\n                l += 1\n            else:\n                return [l + 1, r + 1]",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "sliding window",
      "two pointers"
    ],
    "approach": "Two Pointers"
  },
  {
    "title": "Excel Sheet Column Title",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n        while columnNumber > 0:\n            remainder = (columnNumber - 1) % 26\n            res += chr(ord('A') + remainder)\n            columnNumber = (columnNumber - 1) // 26\n\n        return res[::-1] # reverse output",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "math"
    ],
    "approach": "Greedy"
  },
  {
    "title": "Majority Element",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        res, count = 0, 0\n\n        for n in nums:\n            if count == 0:\n                res = n\n            count += (1 if n == res else -1)\n            \n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "Boyer-Moore Voting Algorithm"
  },
  {
    "title": "Largest Number",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        for i, n in enumerate(nums):\n            nums[i] = str(n)\n\n        def compare(n1, n2):\n            if n1 + n2 > n2 + n1:\n                return -1\n            else:\n                return 1\n\n        nums = sorted(nums, key = cmp_to_key(compare))\n\n        return str(int(\"\".join(nums)))",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Sorting"
  },
  {
    "title": "Repeated Dna Sequences",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findRepeatedDnaSequences(self, s: str) -> list[str]:\n        result = set()\n        previous_sequences = set()\n        for i in range(len(s) - 9):\n            current = s[i:i+10]\n            if current in previous_sequences:\n                result.add(current)\n            previous_sequences.add(current)\n        return list(result)",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "hash table"
    ],
    "approach": "\"Two Pointers\""
  },
  {
    "title": "Rotate Array",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k = k % len(nums)\n        l, r = 0, len(nums) - 1\n        while l < r:\n            nums[l], nums[r] = nums[r], nums[l]\n            l, r = l + 1, r - 1\n            \n        l, r = 0, k - 1\n        while l < r:\n            nums[l], nums[r] = nums[r], nums[l]\n            l, r = l + 1, r - 1\n            \n        l, r = k, len(nums) - 1\n        while l < r:\n            nums[l], nums[r] = nums[r], nums[l]\n            l, r = l + 1, r - 1",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "math",
      "sliding window",
      "two pointers"
    ],
    "approach": "Two Pointers"
  },
  {
    "title": "Reverse Bits",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def reverseBits(self, n: int) -> int:\n        res = 0\n        for i in range(32):\n            bit = (n >> i) & 1\n            res += (bit << (31 - i))\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "\"Bit Manipulation\""
  },
  {
    "title": "Number Of 1 Bits",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        res = 0\n        while n:\n            n &= n - 1\n            res += 1\n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "Greedy"
  },
  {
    "title": "House Robber",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        rob1, rob2 = 0, 0\n\n        for n in nums:\n            temp = max(n + rob1, rob2)\n            rob1 = rob2\n            rob2 = temp\n        return rob2",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Binary Tree Right Side View",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def rightSideView(self, root: TreeNode) -> List[int]:\n        res = []\n        q = collections.deque([root])\n\n        while q:\n            rightSide = None\n            qLen = len(q)\n\n            for i in range(qLen):\n                node = q.popleft()\n                if node:\n                    rightSide = node\n                    q.append(node.left)\n                    q.append(node.right)\n            if rightSide:\n                res.append(rightSide.val)\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "tree"
    ],
    "approach": "Breadth-First Search (BFS)"
  },
  {
    "title": "Number Of Islands",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n\n        islands = 0\n        visit = set()\n        rows, cols = len(grid), len(grid[0])\n\n        def dfs(r, c):\n            if (\n                r not in range(rows)\n                or c not in range(cols)\n                or grid[r][c] == \"0\"\n                or (r, c) in visit\n            ):\n                return\n\n            visit.add((r, c))\n            directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n            for dr, dc in directions:\n                dfs(r + dr, c + dc)\n\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == \"1\" and (r, c) not in visit:\n                    islands += 1\n                    dfs(r, c)\n        return islands\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        def dfs(r, c):\n            if not 0 <= r < len(grid) or not 0 <= c < len(grid[0]) or grid[r][c] == '0':\n                return 0\n            grid[r][c] = '0'\n            dfs(r + 1, c)\n            dfs(r - 1, c)\n            dfs(r, c + 1)\n            dfs(r, c - 1)\n            return 1\n        count = 0\n        for r in range(rows):\n            for c in range(cols):\n                count += dfs(r, c)\n        return count\n\nclass SolutionBFS:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        if not grid:\n            return 0\n\n        rows, cols = len(grid), len(grid[0])\n        visited = set()\n        islands = 0\n\n         def bfs(r, c):\n             q = deque()\n             visited.add((r, c))\n             q.append((r, c))\n           \n             while q:\n                 row, col = q.popleft()\n                 directions = [[1, 0],[-1, 0],[0, 1],[0, -1]]\n               \n                 for dr, dc in directions:\n                     r, c = row + dr, col + dc\n                     if (r) in range(rows) and (c) in range(cols) and grid[r][c] == '1' and (r, c) not in visited:\n                       \n                         q.append((r, c ))\n                         visited.add((r, c ))\n\n         for r in range(rows):\n             for c in range(cols):\n               \n                 if grid[r][c] == \"1\" and (r, c) not in visited:\n                     bfs(r, c)\n                     islands += 1 \n\n         return islands",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "hash table",
      "recursion"
    ],
    "approach": "The main algorithmic approach used is **Depth-First Search (DFS)**."
  },
  {
    "title": "Bitwise And Of Numbers Range",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        res = 0\n\n        for i in range(32):\n            bit = (left >> i) & 1\n            if not bit:\n                continue\n            \n            remain = left % (1 << (i + 1))\n            diff = (1 << (i + 1)) - remain\n            if right - left < diff:\n                res = res | (1 << i)\n        return res\n\nclass Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        i = 0\n        while left != right:\n            left = left >> 1\n            right = right >> 1\n            i += 1\n        return left << i",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "math"
    ],
    "approach": "Greedy"
  },
  {
    "title": "Happy Number",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isHappy(self, n: int) -> bool:\n        slow, fast = n, self.sumSquareDigits(n)\n\n        while slow != fast:\n            fast = self.sumSquareDigits(fast)\n            fast = self.sumSquareDigits(fast)\n            slow = self.sumSquareDigits(slow)\n\n        return True if fast == 1 else False\n\n    def sumSquareDigits(self, n):\n        output = 0\n        while n:\n            output += (n % 10) ** 2\n            n = n // 10\n        return output",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "Hash Map"
  },
  {
    "title": "Remove Linked List Elements",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\n        dummy = ListNode(next=head)\n        prev, curr = dummy, head\n        \n        while curr:\n            nxt = curr.next\n            \n            if curr.val == val:\n                prev.next = nxt\n            else:\n                prev = curr\n            \n            curr = nxt\n        return dummy.next",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "linked list"
    ],
    "approach": "The main algorithmic approach used here is \"Two Pointers\"."
  },
  {
    "title": "Isomorphic Strings",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        mapST, mapTS = {}, {}\n\n        for c1, c2 in zip(s, t):\n            if (c1 in mapST and mapST[c1] != c2) or (c2 in mapTS and mapTS[c2] != c1):\n                return False\n            mapST[c1] = c2\n            mapTS[c2] = c1\n\n        return True",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Hash Map"
  },
  {
    "title": "Reverse Linked List",
    "description": "No description available.",
    "optimal_code": "\n\nclass Solution:\n    def reverseList(self, head: ListNode) -> ListNode:\n        prev, curr = None, head\n\n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        return prev",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "linked list"
    ],
    "approach": "\"Two Pointers\""
  },
  {
    "title": "Course Schedule",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        preMap = {i: [] for i in range(numCourses)}\n\n        for crs, pre in prerequisites:\n            preMap[crs].append(pre)\n\n        visiting = set()\n\n        def dfs(crs):\n            if crs in visiting:\n                return False\n            if preMap[crs] == []:\n                return True\n\n            visiting.add(crs)\n            for pre in preMap[crs]:\n                if not dfs(pre):\n                    return False\n            visiting.remove(crs)\n            preMap[crs] = []\n            return True\n\n        for c in range(numCourses):\n            if not dfs(c):\n                return False\n        return True",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "hash table",
      "recursion"
    ],
    "approach": "The main algorithmic approach used is: **Depth-First Search (DFS)**"
  },
  {
    "title": "Implement Trie Prefix Tree",
    "description": "No description available.",
    "optimal_code": "class TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.end = False\n\n\nclass Trie:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        \"\"\"\n        Inserts a word into the trie.\n        \"\"\"\n        curr = self.root\n        for c in word:\n            i = ord(c) - ord(\"a\")\n            if curr.children[i] is None:\n                curr.children[i] = TrieNode()\n            curr = curr.children[i]\n        curr.end = True\n\n    def search(self, word: str) -> bool:\n        \"\"\"\n        Returns if the word is in the trie.\n        \"\"\"\n        curr = self.root\n        for c in word:\n            i = ord(c) - ord(\"a\")\n            if curr.children[i] is None:\n                return False\n            curr = curr.children[i]\n        return curr.end\n\n    def startsWith(self, prefix: str) -> bool:\n        \"\"\"\n        Returns if there is any word in the trie that starts with the given prefix.\n        \"\"\"\n        curr = self.root\n        for c in prefix:\n            i = ord(c) - ord(\"a\")\n            if curr.children[i] is None:\n                return False\n            curr = curr.children[i]\n        return True",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used here is \"Trie\"."
  },
  {
    "title": "Minimum Size Subarray Sum",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        res = float('inf')\n        l, total = 0, 0\n\n        for r in range(len(nums)):\n            total += nums[r]\n            while total >= target:\n                res = min(res, r - l + 1)\n                total -= nums[l]\n                l += 1\n        return res if res != float('inf') else 0",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "array"
    ],
    "approach": "Two Pointers."
  },
  {
    "title": "Course Schedule Ii",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        prereq = {c: [] for c in range(numCourses)}\n        for crs, pre in prerequisites:\n            prereq[crs].append(pre)\n\n        output = []\n        visit, cycle = set(), set()\n\n        def dfs(crs):\n            if crs in cycle:\n                return False\n            if crs in visit:\n                return True\n\n            cycle.add(crs)\n            for pre in prereq[crs]:\n                if dfs(pre) == False:\n                    return False\n            cycle.remove(crs)\n            visit.add(crs)\n            output.append(crs)\n            return True\n\n        for c in range(numCourses):\n            if dfs(c) == False:\n                return []\n        return output",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "hash table",
      "recursion"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Design Add And Search Words Data Structure",
    "description": "No description available.",
    "optimal_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}  # a : TrieNode\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        cur = self.root\n        for c in word:\n            if c not in cur.children:\n                cur.children[c] = TrieNode()\n            cur = cur.children[c]\n        cur.word = True\n\n    def search(self, word: str) -> bool:\n        def dfs(j, root):\n            cur = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n                if c == \".\":\n                    for child in cur.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in cur.children:\n                        return False\n                    cur = cur.children[c]\n            return cur.word\n\n        return dfs(0, self.root)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "hash table",
      "recursion"
    ],
    "approach": "The main algorithmic approach used here is \"Depth-First Search\" (DFS)."
  },
  {
    "title": "Word Search Ii",
    "description": "No description available.",
    "optimal_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isWord = False\n        self.refs = 0\n\n    def addWord(self, word):\n        cur = self\n        cur.refs += 1\n        for c in word:\n            if c not in cur.children:\n                cur.children[c] = TrieNode()\n            cur = cur.children[c]\n            cur.refs += 1\n        cur.isWord = True\n\n    def removeWord(self, word):\n        cur = self\n        cur.refs -= 1\n        for c in word:\n            if c in cur.children:\n                cur = cur.children[c]\n                cur.refs -= 1\n\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        root = TrieNode()\n        for w in words:\n            root.addWord(w)\n\n        ROWS, COLS = len(board), len(board[0])\n        res, visit = set(), set()\n\n        def dfs(r, c, node, word):\n            if (\n                r not in range(ROWS) \n                or c not in range(COLS)\n                or board[r][c] not in node.children\n                or node.children[board[r][c]].refs < 1\n                or (r, c) in visit\n            ):\n                return\n\n            visit.add((r, c))\n            node = node.children[board[r][c]]\n            word += board[r][c]\n            if node.isWord:\n                node.isWord = False\n                res.add(word)\n                root.removeWord(word)\n\n            dfs(r + 1, c, node, word)\n            dfs(r - 1, c, node, word)\n            dfs(r, c + 1, node, word)\n            dfs(r, c - 1, node, word)\n            visit.remove((r, c))\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                dfs(r, c, root, \"\")\n\n        return list(res)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "hash table",
      "recursion"
    ],
    "approach": "The main algorithmic approach used here is \"Depth-First Search\" (DFS)."
  },
  {
    "title": "House Robber Ii",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        return max(nums[0], self.helper(nums[1:]), self.helper(nums[:-1]))\n\n    def helper(self, nums):\n        rob1, rob2 = 0, 0\n\n        for n in nums:\n            newRob = max(rob1 + n, rob2)\n            rob1 = rob2\n            rob2 = newRob\n        return rob2",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Kth Largest Element In An Array",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        heapify(nums)\n        while len(nums) > k:\n            heappop(nums)\n        return nums[0]\n\nclass Solution1:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        return nums[len(nums) - k]\n\n\nclass Solution2:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        pivot = random.choice(nums)\n        left = [num for num in nums if num > pivot]\n        mid = [num for num in nums if num == pivot]\n        right = [num for num in nums if num < pivot]\n\n        length_left = len(left)\n        length_right = len(right)\n        length_mid = len(mid)\n        if k <= length_left:\n            return self.findKthLargest(left, k)\n        elif k > length_left + length_mid:\n            return self.findKthLargest(right, k - length_mid - length_left)\n        else:\n            return mid[0]",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used is: \"Sorting\""
  },
  {
    "title": "Contains Duplicate",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        hashset = set()\n\n        for n in nums:\n            if n in hashset:\n                return True\n            hashset.add(n)\n        return False",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Hash Map"
  },
  {
    "title": "Contains Duplicate Ii",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        window = set()\n        L = 0\n\n        for R in range(len(nums)):\n            if R - L > k:\n                window.remove(nums[L])\n                L += 1\n            if nums[R] in window:\n                return True\n            window.add(nums[R])\n        return False",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "hash table"
    ],
    "approach": "Sliding Window"
  },
  {
    "title": "Maximal Square",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {}  # map each (r, c) -> maxLength of square\n\n        def helper(r, c):\n            if r >= ROWS or c >= COLS:\n                return 0\n\n            if (r, c) not in cache:\n                down = helper(r + 1, c)\n                right = helper(r, c + 1)\n                diag = helper(r + 1, c + 1)\n\n                cache[(r, c)] = 0\n                if matrix[r][c] == \"1\":\n                    cache[(r, c)] = 1 + min(down, right, diag)\n            return cache[(r, c)]\n\n        helper(0, 0)\n        return max(cache.values()) ** 2",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Implement Stack Using Queues",
    "description": "No description available.",
    "optimal_code": "class MyStack:\n    def __init__(self):\n        self.q = deque()\n\n    def push(self, x: int) -> None:\n        self.q.append(x)\n        \n        for _ in range(len(self.q) - 1):\n            self.q.append(self.q.popleft())\n\n    def pop(self) -> int:\n        return self.q.popleft()\n\n    def top(self) -> int:\n        return self.q[0]\n\n    def empty(self) -> bool:\n        return len(self.q) == 0",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "array"
    ],
    "approach": "The main algorithmic approach used is \"Deque Manipulation\"."
  },
  {
    "title": "Invert Binary Tree",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n            return None\n        \n        root.left, root.right = root.right, root.left\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        return root",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "tree"
    ],
    "approach": "Recursion."
  },
  {
    "title": "Kth Smallest Element In A Bst",
    "description": "No description available.",
    "optimal_code": "\n\nclass Solution:\n    def kthSmallest(self, root: TreeNode, k: int) -> int:\n        stack = []\n        curr = root\n\n        while stack or curr:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            k -= 1\n            if k == 0:\n                return curr.val\n            curr = curr.right",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "tree"
    ],
    "approach": "In-order traversal."
  },
  {
    "title": "Power Of Two",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        x = 1\n        while x < n:\n            x *= 2\n        return x == n        \n\nclass Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        return n > 0 and (n & (n - 1)) == 0\n\nclass Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        return n > 0 and ((1 << 30) % n) == 0",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "The main algorithmic approach used in each of these solutions is:"
  },
  {
    "title": "Implement Queue Using Stacks",
    "description": "No description available.",
    "optimal_code": "class MyQueue:\n    \n    def __init__(self):\n        self.append_stack = []\n        self.inverted_stack = []\n\n    def push(self, x: int) -> None:\n        self.append_stack.append(x)\n\n    def pop(self) -> int:\n        if not self.inverted_stack:\n            while self.append_stack:\n                self.inverted_stack.append(self.append_stack.pop())\n        return self.inverted_stack.pop()\n\n    def peek(self) -> int:\n        if not self.inverted_stack:\n            while self.append_stack:\n                self.inverted_stack.append(self.append_stack.pop())\n        return self.inverted_stack[-1]\n\n    def empty(self) -> bool:\n        return not (self.append_stack or self.inverted_stack)",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Stacks\" with a combination of \"Two Pointers\"."
  },
  {
    "title": "Palindrome Linked List",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isPalindrome(self, head: ListNode) -> bool:\n        fast = head\n        slow = head\n        \n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            \n        prev = None\n        while slow:\n            tmp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = tmp\n        \n        left, right = head, prev\n        while right:\n            if left.val != right.val:\n                return False\n            left = left.next\n            right = right.next\n        return True",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "linked list"
    ],
    "approach": "The main algorithmic approach used is \"Two Pointers\"."
  },
  {
    "title": "Lowest Common Ancestor Of A Binary Search Tree",
    "description": "No description available.",
    "optimal_code": "\n\nclass Solution:\n    def lowestCommonAncestor(\n        self, root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n    ) -> \"TreeNode\":\n        while True:\n            if root.val < p.val and root.val < q.val:\n                root = root.right\n            elif root.val > p.val and root.val > q.val:\n                root = root.left\n            else:\n                return root",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "tree"
    ],
    "approach": "\"Binary Search\""
  },
  {
    "title": "Lowest Common Ancestor Of A Binary Tree",
    "description": "No description available.",
    "optimal_code": "\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        if not root:\n            return\n        if root == p or root == q:\n            return root\n\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n\n        if left and right:\n            return root\n\n        if left:\n            return left\n        if right:\n            return right\n\n        return None",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "tree"
    ],
    "approach": "Recursive DFS"
  },
  {
    "title": "Product Of Array Except Self",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res = [1] * (len(nums))\n\n        for i in range(1, len(nums)):\n            res[i] = res[i-1] * nums[i-1]\n        postfix = 1\n        for i in range(len(nums) - 1, -1, -1):\n            res[i] *= postfix\n            postfix *= nums[i]\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array"
    ],
    "approach": "The main algorithmic approach used is \"Two Passes\" or \"Prefix and Postfix\" which involves using a combination of prefix sum and postifix product calculation to solve the problem."
  },
  {
    "title": "Sliding Window Maximum",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        output = []\n        q = collections.deque()  # index\n        l = r = 0\n        while r < len(nums):\n            while q and nums[q[-1]] < nums[r]:\n                q.pop()\n            q.append(r)\n\n            if l > q[0]:\n                q.popleft()\n\n            if (r + 1) >= k:\n                output.append(nums[q[0]])\n                l += 1\n            r += 1\n\n        return output",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "\"Deque and Two Pointers\" or \"Sliding Window with Priority Queue\""
  },
  {
    "title": "Different Ways To Add Parentheses",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def diffWaysToCompute(self, s: str) -> List[int]:\n        def f(s):\n            res = []\n            for i, c in enumerate(s):\n                if c in '+-*':\n                    for l in f(s[:i]):\n                        for r in f(s[i + 1:]):\n                            res.append(eval(f'{l}{c}{r}'))\n            \n            return res or [int(s)]\n        return f(s)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "Dynamic Programming with Recursion"
  },
  {
    "title": "Valid Anagram",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n\n        countS, countT = {}, {}\n\n        for i in range(len(s)):\n            countS[s[i]] = 1 + countS.get(s[i], 0)\n            countT[t[i]] = 1 + countT.get(t[i], 0)\n        return countS == countT",
    "time_complexity": "O(log n)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "binary search",
      "hash table"
    ],
    "approach": "Hash Map."
  },
  {
    "title": "Meeting Rooms",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    \"\"\"\n    @param intervals: an array of meeting time intervals\n    @return: if a person could attend all meetings\n    \"\"\"\n\n    def canAttendMeetings(self, intervals):\n        intervals.sort(key=lambda i: i[0])\n\n        for i in range(1, len(intervals)):\n            i1 = intervals[i - 1]\n            i2 = intervals[i]\n\n            if i1[1] > i2[0]:\n                return False\n        return True",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Sorting"
  },
  {
    "title": "Meeting Rooms Ii",
    "description": "No description available.",
    "optimal_code": "def minMeetingRooms(self, intervals: List[List[int]]) -> int:\n        time = []\n        for start, end in intervals:\n            time.append((start, 1))\n            time.append((end, -1))\n        \n        time.sort(key=lambda x: (x[0], x[1]))\n        \n        count = 0\n        max_count = 0\n        for t in time:\n            count += t[1]\n            max_count = max(max_count, count)\n        return max_count",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Sorting"
  },
  {
    "title": "Meeting Rooms",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    \"\"\"\n    @param intervals: an array of meeting time intervals\n    @return: the minimum number of conference rooms required\n    \"\"\"\n\n    def minMeetingRooms(self, intervals):\n        start = sorted([i[0] for i in intervals])\n        end = sorted([i[1] for i in intervals])\n\n        res, count = 0, 0\n        s, e = 0, 0\n        while s < len(intervals):\n            if start[s] < end[e]:\n                s += 1\n                count += 1\n            else:\n                e += 1\n                count -= 1\n            res = max(res, count)\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Two Pointers\"."
  },
  {
    "title": "Graph Valid Tree",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    \"\"\"\n    @param n: An integer\n    @param edges: a list of undirected edges\n    @return: true if it's a valid tree, or false\n    \"\"\"\n\n    def validTree(self, n, edges):\n        if not n:\n            return True\n        adj = {i: [] for i in range(n)}\n        for n1, n2 in edges:\n            adj[n1].append(n2)\n            adj[n2].append(n1)\n\n        visit = set()\n\n        def dfs(i, prev):\n            if i in visit:\n                return False\n\n            visit.add(i)\n            for j in adj[i]:\n                if j == prev:\n                    continue\n                if not dfs(j, i):\n                    return False\n            return True\n\n        return dfs(0, -1) and n == len(visit)\n    \n    \n    \n    class Solution:\n    \"\"\"\n    @param n: An integer\n    @param edges: a list of undirected edges\n    @return: true if it's a valid tree, or false\n    \"\"\"\n    def __find(self, n: int) -> int:\n        while n != self.parents.get(n, n):\n            n = self.parents.get(n, n)\n        return n\n\n    def __connect(self, n: int, m: int) -> None:\n        pn = self.__find(n)\n        pm = self.__find(m)\n        if pn == pm:\n            return\n        if self.heights.get(pn, 1) > self.heights.get(pm, 1):\n            self.parents[pn] = pm\n        else:\n            self.parents[pm] = pn\n            self.heights[pm] = self.heights.get(pn, 1) + 1\n        self.components -= 1\n\n    def valid_tree(self, n: int, edges: List[List[int]]) -> bool:\n        self.parents = {}\n        self.heights = {}\n        self.components = n\n\n        for e1, e2 in edges:\n            if self.__find(e1) == self.__find(e2):  # 'redundant' edge\n                return False\n            self.__connect(e1, e2)\n\n        return self.components == 1  # forest contains one tree",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "hash table",
      "recursion"
    ],
    "approach": "The main algorithmic approach used is \"Depth-First Search (DFS)\" and also \"Union-Find\" or \"Disjoint Set\"."
  },
  {
    "title": "Ugly Number",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isUgly(self, n: int) -> bool:\n        if n <= 0:\n            return False\n        \n        for p in [2, 3, 5]:\n            while n % p == 0:\n                n = n // p\n        return n == 1",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "Greedy"
  },
  {
    "title": "Missing Number",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        res = len(nums)\n\n        for i in range(len(nums)):\n            res += i - nums[i]\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "array"
    ],
    "approach": "\"Greedy\""
  },
  {
    "title": "Alien Dictionary",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def alienOrder(self, words: List[str]) -> str:\n        adj = {char: set() for word in words for char in word}\n\n        for i in range(len(words) - 1):\n            w1, w2 = words[i], words[i + 1]\n            minLen = min(len(w1), len(w2))\n            if len(w1) > len(w2) and w1[:minLen] == w2[:minLen]:\n                return \"\"\n            for j in range(minLen):\n                if w1[j] != w2[j]:\n                    print(w1[j], w2[j])\n                    adj[w1[j]].add(w2[j])\n                    break\n\n        visited = {}  # {char: bool} False visited, True current path\n        res = []\n\n        def dfs(char):\n            if char in visited:\n                return visited[char]\n\n            visited[char] = True\n\n            for neighChar in adj[char]:\n                if dfs(neighChar):\n                    return True\n\n            visited[char] = False\n            res.append(char)\n\n        for char in adj:\n            if dfs(char):\n                return \"\"\n\n        res.reverse()\n        return \"\".join(res)",
    "time_complexity": "O(log n)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "binary search",
      "dfs",
      "hash table",
      "recursion"
    ],
    "approach": "The main algorithmic approach used is \"Depth-First Search\" (DFS)."
  },
  {
    "title": "Encode And Decode Strings",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def encode(self, strs):\n        res = \"\"\n        for s in strs:\n            res += str(len(s)) + \"#\" + s\n        return res\n\n    def decode(self, s):\n        res = []\n        i = 0\n        \n        while i < len(s):\n            j = i\n            while s[j] != '#':\n                j += 1\n            length = int(s[i:j])\n            i = j + 1\n            j = i + length\n            res.append(s[i:j])\n            i = j\n            \n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Iterative String Processing\" with a hint of \"Two Pointers\" in the decode function."
  },
  {
    "title": "H Index",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def hIndex(self, citations: List[int]) -> int:\n        length = len(citations)\n        citations.sort()\n        for i in range(length):\n            if citations[i] >= length - i:\n                return length - i\n        return 0",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "array"
    ],
    "approach": "Sorting"
  },
  {
    "title": "First Bad Version",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def firstBadVersion(self, n: int) -> int:\n        l, r = 1, n\n        while l < r:\n            v = (l + r) // 2\n            if isBadVersion(v):\n                r = v\n            else:\n                l = v + 1\n        return l",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "math",
      "sliding window",
      "two pointers"
    ],
    "approach": "Binary Search"
  },
  {
    "title": "Wiggle Sort",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def wiggleSort(self, nums: List[int]) -> None:\n        for i in range(1, len(nums)):\n            if (i % 2 == 1 and nums[i] < nums[i - 1]) or (i % 2 == 0 and nums[i] > nums[i - 1]):\n                nums[i], nums[i - 1] = nums[i - 1], nums[i]",
    "time_complexity": "O(n)",
    "space_complexity": "Unknown",
    "tags": [
      "math"
    ],
    "approach": "The main algorithmic approach used is \"Sorting\"."
  },
  {
    "title": "Move Zeroes",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        slow = 0\n        for fast in range(len(nums)):\n            \n            if nums[fast] != 0 and nums[slow] == 0:\n                nums[slow], nums[fast] = nums[fast], nums[slow]\n\n            if nums[slow] != 0:\n                slow += 1",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "array"
    ],
    "approach": "Two Pointers"
  },
  {
    "title": "Walls And Gates",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    \"\"\"\n    @param rooms: m x n 2D grid\n    @return: nothing\n    \"\"\"\n\n    def walls_and_gates(self, rooms: List[List[int]]):\n        ROWS, COLS = len(rooms), len(rooms[0])\n        visit = set()\n        q = deque()\n\n        def addRooms(r, c):\n            if (\n                min(r, c) < 0\n                or r == ROWS\n                or c == COLS\n                or (r, c) in visit\n                or rooms[r][c] == -1\n            ):\n                return\n            visit.add((r, c))\n            q.append([r, c])\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if rooms[r][c] == 0:\n                    q.append([r, c])\n                    visit.add((r, c))\n\n        dist = 0\n        while q:\n            for i in range(len(q)):\n                r, c = q.popleft()\n                rooms[r][c] = dist\n                addRooms(r + 1, c)\n                addRooms(r - 1, c)\n                addRooms(r, c + 1)\n                addRooms(r, c - 1)\n            dist += 1",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "hash table"
    ],
    "approach": "Breadth-First Search (BFS)"
  },
  {
    "title": "Find The Duplicate Number",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        slow, fast = 0, 0\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n\n        slow2 = 0\n        while True:\n            slow = nums[slow]\n            slow2 = nums[slow2]\n            if slow == slow2:\n                return slow",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Floyd's Tortoise and Hare (also known as \"Cycle Detection\" or \"Finding a Loop in Linked List\")"
  },
  {
    "title": "Word Pattern",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        words = s.split(\" \")\n        if len(pattern) != len(words):\n            return False\n        charToWord = {}\n        wordToChar = {}\n        \n        for c, w in zip(pattern, words):\n            if c in charToWord and charToWord[c] != w:\n                return False\n            if w in wordToChar and wordToChar[w] != c:\n                return False\n            charToWord[c] = w\n            wordToChar[w] = c\n        return True",
    "time_complexity": "O(log n)",
    "space_complexity": "O(n)",
    "tags": [
      "binary search",
      "dynamic programming",
      "hash table"
    ],
    "approach": "Hash Map (or more specifically, Dictionary)"
  },
  {
    "title": "Find Median From Data Stream",
    "description": "No description available.",
    "optimal_code": "class MedianFinder:\n    def __init__(self):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        self.small, self.large = [], []  # maxHeap, minHeap (python default)\n\n    def addNum(self, num: int) -> None:\n        if self.large and num > self.large[0]:\n            heapq.heappush(self.large, num)\n        else:\n            heapq.heappush(self.small, -1 * num)\n\n        if len(self.small) > len(self.large) + 1:\n            val = -1 * heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.large) > len(self.small) + 1:\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -1 * val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -1 * self.small[0]\n        elif len(self.large) > len(self.small):\n            return self.large[0]\n        return (-1 * self.small[0] + self.large[0]) / 2.0",
    "time_complexity": "O(log n)",
    "space_complexity": "O(1)",
    "tags": [
      "binary search"
    ],
    "approach": "The main algorithmic approach used is \"Priority Queue\" (specifically, a min-heap and a max-heap)."
  },
  {
    "title": "Serialize And Deserialize Binary Tree",
    "description": "No description available.",
    "optimal_code": "\n\nclass Codec:\n    def serialize(self, root):\n        res = []\n\n        def dfs(node):\n            if not node:\n                res.append(\"N\")\n                return\n            res.append(str(node.val))\n            dfs(node.left)\n            dfs(node.right)\n\n        dfs(root)\n        return \",\".join(res)\n\n    def deserialize(self, data):\n        vals = data.split(\",\")\n\n        def dfs():\n            val = vals.pop(0)\n            if val == \"N\":\n                return None\n            node = TreeNode(val=int(val))\n            node.left = dfs()\n            node.right = dfs()\n            return node\n\n        return dfs()",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "recursion",
      "tree"
    ],
    "approach": "\"DFS\" (Depth-First Search)"
  },
  {
    "title": "Longest Increasing Subsequence",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        LIS = [1] * len(nums)\n\n        for i in range(len(nums) - 1, -1, -1):\n            for j in range(i + 1, len(nums)):\n                if nums[i] < nums[j]:\n                    LIS[i] = max(LIS[i], 1 + LIS[j])\n        return max(LIS)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "array"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Range Sum Query Immutable",
    "description": "No description available.",
    "optimal_code": "class NumArray:\n\n    def __init__(self, nums: List[int]):\n        self.prefix = []\n        cur = 0\n        for n in nums:\n            cur += n\n            self.prefix.append(cur)\n        \n        \n    def sumRange(self, left: int, right: int) -> int:\n        r = self.prefix[right] \n        l = self.prefix[left - 1] if left > 0 else 0\n        return r - l",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Range Sum Query 2D Immutable",
    "description": "No description available.",
    "optimal_code": "class NumMatrix:\n    def __init__(self, matrix):\n        self.sum_ = [[0] * (len(matrix[0]) + 1) for _ in range(len(matrix) + 1)]\n        for i, line in enumerate(matrix):\n            previous = 0\n            for j, num in enumerate(line):\n                previous += num\n                above = self.sum_[i][j + 1]\n                self.sum_[i + 1][j + 1] = previous + above\n\n    def sumRegion(self, row1, col1, row2, col2):\n        sum_col2 = self.sum_[row2 + 1][col2 + 1] - self.sum_[row1][col2 + 1]\n        sum_col1 = self.sum_[row2 + 1][col1] - self.sum_[row1][col1]\n        return sum_col2 - sum_col1",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "array"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Best Time To Buy And Sell Stock With Cooldown",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n\n        dp = {}  # key=(i, buying) val=max_profit\n\n        def dfs(i, buying):\n            if i >= len(prices):\n                return 0\n            if (i, buying) in dp:\n                return dp[(i, buying)]\n\n            cooldown = dfs(i + 1, buying)\n            if buying:\n                buy = dfs(i + 1, not buying) - prices[i]\n                dp[(i, buying)] = max(buy, cooldown)\n            else:\n                sell = dfs(i + 2, not buying) + prices[i]\n                dp[(i, buying)] = max(sell, cooldown)\n            return dp[(i, buying)]\n\n        return dfs(0, True)",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "dynamic programming",
      "hash table",
      "recursion"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Burst Balloons",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        cache = {}\n        nums = [1] + nums + [1]\n\n        for offset in range(2, len(nums)):\n            for left in range(len(nums) - offset):\n                right = left + offset\n                for pivot in range(left + 1, right):\n                    coins = nums[left] * nums[pivot] * nums[right]\n                    coins += cache.get((left, pivot), 0) + cache.get((pivot, right), 0)\n                    cache[(left, right)] = max(coins, cache.get((left, right), 0))\n        return cache.get((0, len(nums) - 1), 0)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "hash table"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Coin Change",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount + 1] * (amount + 1)\n        dp[0] = 0\n\n        for a in range(1, amount + 1):\n            for c in coins:\n                if a - c >= 0:\n                    dp[a] = min(dp[a], 1 + dp[a - c])\n        return dp[amount] if dp[amount] != amount + 1 else -1",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "dynamic programming"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Number Of Connected Components In An Undirected Graph",
    "description": "No description available.",
    "optimal_code": "class UnionFind:\n    def __init__(self):\n        self.f = {}\n\n    def findParent(self, x):\n        y = self.f.get(x, x)\n        if x != y:\n            y = self.f[x] = self.findParent(y)\n        return y\n\n    def union(self, x, y):\n        self.f[self.findParent(x)] = self.findParent(y)\n\n\nclass Solution:\n    def countComponents(self, n: int, edges: List[List[int]]) -> int:\n        dsu = UnionFind()\n        for a, b in edges:\n            dsu.union(a, b)\n        return len(set(dsu.findParent(x) for x in range(n)))",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "dynamic programming",
      "hash table"
    ],
    "approach": "Disjoint Set Union (DSU) or Union-Find."
  },
  {
    "title": "Longest Increasing Path In A Matrix",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        dp = {}  # (r, c) -> LIP\n\n        def dfs(r, c, prevVal):\n            if r < 0 or r == ROWS or c < 0 or c == COLS or matrix[r][c] <= prevVal:\n                return 0\n            if (r, c) in dp:\n                return dp[(r, c)]\n\n            res = 1\n            res = max(res, 1 + dfs(r + 1, c, matrix[r][c]))\n            res = max(res, 1 + dfs(r - 1, c, matrix[r][c]))\n            res = max(res, 1 + dfs(r, c + 1, matrix[r][c]))\n            res = max(res, 1 + dfs(r, c - 1, matrix[r][c]))\n            dp[(r, c)] = res\n            return res\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                dfs(r, c, -1)\n        return max(dp.values())",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "dynamic programming",
      "hash table",
      "recursion"
    ],
    "approach": "Dynamic Programming (DP) with Memoization."
  },
  {
    "title": "Reconstruct Itinerary",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        adj = {src: [] for src, dst in tickets}\n        res = []\n\n        for src, dst in tickets:\n            adj[src].append(dst)\n\n        for key in adj:\n            adj[key].sort()\n\n        def dfs(adj, src):\n            if src in adj:\n                destinations = adj[src][:]\n                while destinations:\n                    dest = destinations[0]\n                    adj[src].pop(0)\n                    dfs(adj, dest)\n                    destinations = adj[src][:]\n            res.append(src)\n\n        dfs(adj, \"JFK\")\n        res.reverse()\n\n        if len(res) != len(tickets) + 1:\n            return []\n\n        return res",
    "time_complexity": "O(log n)",
    "space_complexity": "O(n)",
    "tags": [
      "binary search",
      "dfs",
      "recursion"
    ],
    "approach": "DFS (Depth-First Search)"
  },
  {
    "title": "Increasing Triplet Subsequence",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def increasingTriplet(self, nums: List[int]) -> bool:\n        first = float('inf')  # Initialize first to positive infinity\n        second = float('inf')  # Initialize second to positive infinity\n        \n        for num in nums:\n            if num <= first:\n                first = num  # Update first if num is smaller or equal\n            elif num <= second:\n                second = num  # Update second if num is smaller or equal\n            else:\n                return True  # We found a triplet: first < second < num\n        \n        return False  # No triplet exists",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Greedy"
  },
  {
    "title": "Counting Bits",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def countBits(self, n: int) -> List[int]:\n        dp = [0] * (n + 1)\n        offset = 1\n\n        for i in range(1, n + 1):\n            if offset * 2 == i:\n                offset = i\n            dp[i] = 1 + dp[i - offset]\n        return dp\n\nclass Solution2:\n    def countBits(self, n: int) -> List[int]:\n        res = [0] * (n + 1)\n        for i in range(1, n + 1):\n            if i % 2 == 1:\n                res[i] = res[i - 1] + 1\n            else:\n                res[i] = res[i // 2]\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "dynamic programming",
      "hash table",
      "math"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Reverse String",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        l = 0\n        r = len(s) - 1\n        while l < r:\n            s[l],s[r] = s[r],s[l]\n            l += 1\n            r -= 1",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "sliding window",
      "two pointers"
    ],
    "approach": "Two Pointers"
  },
  {
    "title": "Top K Frequent Elements",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count = {}\n        freq = [[] for i in range(len(nums) + 1)]\n\n        for n in nums:\n            count[n] = 1 + count.get(n, 0)\n        for n, c in count.items():\n            freq[c].append(n)\n\n        res = []\n        for i in range(len(freq) - 1, 0, -1):\n            res += freq[i]\n            if len(res) == k:\n                return res",
    "time_complexity": "O(log n)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "binary search",
      "hash table"
    ],
    "approach": "The main algorithmic approach used is \"Hash Map\" and \"Sorting\"."
  },
  {
    "title": "Intersection Of Two Arrays",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        seen = set(nums1)\n\n        res = []\n        for n in nums2:\n            if n in seen:\n                res.append(n)\n                seen.remove(n)\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Hash Map"
  },
  {
    "title": "Intersection Of Two Arrays Ii",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        counter1 = Counter(nums1)\n        counter2 = Counter(nums2)\n\n        counter1 = defaultdict(int, counter1)\n        counter2 = defaultdict(int, counter2)\n\n        intersection = []\n\n        for num, freq in counter1.items():\n            min_freq = min(freq, counter2[num])\n            if min_freq > 0:\n                intersection.extend([num] * min_freq)\n\n        return intersection",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "\"Hash Map\" and \"Sorting\" (due to using Counter)"
  },
  {
    "title": "Design Twitter",
    "description": "No description available.",
    "optimal_code": "class Twitter:\n    def __init__(self):\n        self.count = 0\n        self.tweetMap = defaultdict(list)  # userId -> list of [count, tweetIds]\n        self.followMap = defaultdict(set)  # userId -> set of followeeId\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.tweetMap[userId].append([self.count, tweetId])\n        self.count -= 1\n\n    def getNewsFeed(self, userId: int) -> List[int]:\n        res = []\n        minHeap = []\n\n        self.followMap[userId].add(userId)\n        for followeeId in self.followMap[userId]:\n            if followeeId in self.tweetMap:\n                index = len(self.tweetMap[followeeId]) - 1\n                count, tweetId = self.tweetMap[followeeId][index]\n                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])\n\n        while minHeap and len(res) < 10:\n            count, tweetId, followeeId, index = heapq.heappop(minHeap)\n            res.append(tweetId)\n            if index >= 0:\n                count, tweetId = self.tweetMap[followeeId][index]\n                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        self.followMap[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followeeId in self.followMap[followerId]:\n            self.followMap[followerId].remove(followeeId)",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "The main algorithmic approach used is \"Priority Queue\" (specifically a Min Heap)."
  },
  {
    "title": "Valid Perfect Square",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        for i in range(1, num+1):\n            if i * i == num:\n                return True\n            if i* i > num:\n                return False\n    \n    \n    \n    def isPerfectSquare_2(self, num: int) -> bool:\n        l ,r = 1, num\n        while l <= r:\n            mid = (l +r) // 2\n            if mid * mid > num:\n                r = mid - 1\n            elif mid * mid < num:\n                l = mid + 1\n            else:\n                return True\n        return False",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "Binary Search."
  },
  {
    "title": "Sum Of Two Integers",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def getSum(self, a: int, b: int) -> int:\n        def add(a, b):\n            if not a or not b:\n                return a or b\n            return add(a ^ b, (a & b) << 1)\n\n        if a * b < 0:  # assume a < 0, b > 0\n            if a > 0:\n                return self.getSum(b, a)\n            if add(~a, 1) == b:  # -a == b\n                return 0\n            if add(~a, 1) < b:  # -a < b\n                return add(~add(add(~a, 1), add(~b, 1)), 1)  # -add(-a, -b)\n\n        return add(a, b)  # a*b >= 0 or (-a) > b > 0",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Bit Manipulation\"."
  },
  {
    "title": "Guess Number Higher Or Lower",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def guessNumber(self, n: int) -> int:\n        \n        low = 1\n        high = n\n        \n        while True:\n            mid = low + (high - low) // 2\n            myGuess = guess(mid)\n            if myGuess == 1:\n                low = mid + 1\n            elif myGuess == -1:\n                high = mid - 1\n            else:\n                return mid",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "Binary Search"
  },
  {
    "title": "Combination Sum Iv",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def combinationSum4(self, nums: List[int], target: int) -> int:\n        cache = {0: 1}\n\n        for total in range(1, target + 1):\n            cache[total] = 0\n            for n in nums:\n                cache[total] += cache.get(total - n, 0)\n        return cache[target]\n\n        def dfs(total):\n            if total == target:\n                return 1\n            if total > target:\n                return 0\n            if total in cache:\n                return cache[total]\n\n            cache[total] = 0\n            for n in nums:\n                cache[total] += dfs(total + n)\n            return cache[total]\n\n        return dfs(0)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "dfs",
      "recursion"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Insert Delete Getrandom O1",
    "description": "No description available.",
    "optimal_code": "from random import choice\n\n\nclass RandomizedSet:\n\n    def __init__(self):\n        self.dict = {}\n        self.list = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.dict:\n            return False\n\n        self.dict[val] = len(self.list)\n        self.list.append(val)\n\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.dict:\n            return False\n\n        idx, last_element = self.dict[val], self.list[-1]\n        self.list[idx], self.dict[last_element] = last_element, idx\n        self.list.pop()\n        del self.dict[val]\n\n        return True\n\n    def getRandom(self) -> int:\n        return choice(self.list)",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Hash Map"
  },
  {
    "title": "Ransom Note",
    "description": "No description available.",
    "optimal_code": "from collections import Counter\n\nclass Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        r_counter = Counter(ransomNote)\n        m_counter = Counter(magazine)\n        for c in ransomNote:\n            if m_counter[c] < r_counter[c]:\n                return False\n        return True",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used is: \"Counting\" or \"Frequency Counting\"."
  },
  {
    "title": "Is Subsequence",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        i, j = 0, 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "\"Two Pointers\""
  },
  {
    "title": "Decode String",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n\n        for char in s:\n            if char is not \"]\":\n                stack.append(char)\n            else:\n                sub_str = \"\"\n                while stack[-1] is not \"[\":\n                    sub_str = stack.pop() + sub_str\n                stack.pop()\n\n                multiplier = \"\"\n                while stack and stack[-1].isdigit():\n                    multiplier = stack.pop() + multiplier\n\n                stack.append(int(multiplier) * sub_str)\n\n        return \"\".join(stack)",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Stack\"."
  },
  {
    "title": "Remove K Digits",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def removeKdigits(self, num: str, k: int) -> str:\n        stack = []\n        for i in num:\n            while stack and stack[-1] > i and k > 0:\n                k -= 1\n                stack.pop()\n            if stack or i is not \"0\":\n                stack.append(i)\n        if k:\n            stack = stack[:-k]\n        return ''.join(stack) or '0'",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "\"Stack\" and/or \"Greedy\""
  },
  {
    "title": "Split Array Largest Sum",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def splitArray(self, nums: List[int], m: int) -> int:\n        def canSplit(largest):\n            subarray = 0\n            curSum = 0\n            for n in nums:\n                curSum += n\n                if curSum > largest:\n                    subarray += 1\n                    curSum = n\n            return subarray + 1 <= m\n\n        l, r = max(nums), sum(nums)\n        res = r\n        while l <= r:\n            mid = l + ((r - l) // 2)\n            if canSplit(mid):\n                res = mid\n                r = mid - 1\n            else:\n                l = mid + 1\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "math"
    ],
    "approach": "Binary Search"
  },
  {
    "title": "Partition Equal Subset Sum",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        if sum(nums) % 2:\n            return False\n\n        dp = set()\n        dp.add(0)\n        target = sum(nums) // 2\n\n        for i in range(len(nums) - 1, -1, -1):\n            nextDP = set()\n            for t in dp:\n                if (t + nums[i]) == target:\n                    return True\n                nextDP.add(t + nums[i])\n                nextDP.add(t)\n            dp = nextDP\n        return False",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "dynamic programming",
      "hash table",
      "math"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Pacific Atlantic Water Flow",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n        ROWS, COLS = len(heights), len(heights[0])\n        pac, atl = set(), set()\n\n        def dfs(r, c, visit, prevHeight):\n            if (\n                (r, c) in visit\n                or r < 0\n                or c < 0\n                or r == ROWS\n                or c == COLS\n                or heights[r][c] < prevHeight\n            ):\n                return\n            visit.add((r, c))\n            dfs(r + 1, c, visit, heights[r][c])\n            dfs(r - 1, c, visit, heights[r][c])\n            dfs(r, c + 1, visit, heights[r][c])\n            dfs(r, c - 1, visit, heights[r][c])\n\n        for c in range(COLS):\n            dfs(0, c, pac, heights[0][c])\n            dfs(ROWS - 1, c, atl, heights[ROWS - 1][c])\n\n        for r in range(ROWS):\n            dfs(r, 0, pac, heights[r][0])\n            dfs(r, COLS - 1, atl, heights[r][COLS - 1])\n\n        res = []\n        for r in range(ROWS):\n            for c in range(COLS):\n                if (r, c) in pac and (r, c) in atl:\n                    res.append([r, c])\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "hash table",
      "recursion"
    ],
    "approach": "DFS"
  },
  {
    "title": "Longest Repeating Character Replacement",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        count = {}\n        \n        l = 0\n        maxf = 0\n        for r in range(len(s)):\n            count[s[r]] = 1 + count.get(s[r], 0)\n            maxf = max(maxf, count[s[r]])\n\n            if (r - l + 1) - maxf > k:\n                count[s[l]] -= 1\n                l += 1\n\n        return (r - l + 1)",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "hash table"
    ],
    "approach": "The main algorithmic approach used is \"Sliding Window\"."
  },
  {
    "title": "Non Overlapping Intervals",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort()\n        res = 0\n        prevEnd = intervals[0][1]\n        for start, end in intervals[1:]:\n            if start >= prevEnd:\n                prevEnd = end\n            else:\n                res += 1\n                prevEnd = min(end, prevEnd)\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "\"Sorting\""
  },
  {
    "title": "Find All Anagrams In A String",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        \n        startIndex = 0\n        pMap, sMap = {}, {}\n        res = []\n        \n        for char in p:\n            pMap[char] = 1 + pMap.get(char, 0)\n        \n        for i in range(len(s)):\n            sMap[s[i]] = 1 + sMap.get(s[i], 0)\n\n            if i >= len(p) - 1:\n                if sMap == pMap:\n                    res.append(startIndex)\n                \n                if s[startIndex] in sMap:\n                    sMap[s[startIndex]] -= 1\n                    if sMap[s[startIndex]] == 0:\n                        del sMap[s[startIndex]]\n                startIndex += 1\n        \n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "hash table"
    ],
    "approach": "\"Hash Map\" and \"Sliding Window\"."
  },
  {
    "title": "Arranging Coins",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def arrangeCoins(self, n: int) -> int:\n        l, r = 1, n\n        res = 0\n        while l <=r:\n            mid = (l+r)//2\n            coins = (mid /2) * (mid+1)\n            if coins > n:\n                r = mid - 1\n            else:\n                l = mid + 1\n                res = max(mid, res)\n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "math"
    ],
    "approach": "Binary Search"
  },
  {
    "title": "Find All Duplicates In An Array",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findDuplicates(self, nums: List[int]) -> List[int]:\n        res = []\n\n        for n in nums:\n            n = abs(n)\n            if nums[n - 1] < 0:\n                res.append(n)\n            nums[n - 1] = -nums[n - 1]\n        \n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "One Pointer"
  },
  {
    "title": "Find All Numbers Disappeared In An Array",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\n        for n in nums:\n            i = abs(n) - 1\n            nums[i] = -1 * abs(nums[i])\n\n        res = []\n        for i, n in enumerate(nums):\n            if n > 0:\n                res.append(i + 1)\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "\"Hash Map\""
  },
  {
    "title": "Delete Node In A Bst",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\n        if not root:\n            return root\n        \n        if key > root.val:\n            root.right = self.deleteNode(root.right, key)\n        elif key < root.val:\n            root.left = self.deleteNode(root.left, key)\n        else:\n            if not root.left:\n                return root.right\n            elif not root.right:\n                return root.left\n            \n            cur = root.right\n            while cur.left:\n                cur = cur.left \n            root.val = cur.val\n            root.right = self.deleteNode(root.right, root.val)\n        return root",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "tree"
    ],
    "approach": "\"Recursive Tree Traversal\""
  },
  {
    "title": "Minimum Number Of Arrows To Burst Balloons",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\n        points.sort()\n\n        res = len(points)\n        prev = points[0]\n        for i in range(1, len(points)):\n            curr = points[i]\n            if curr[0] <= prev[1]:\n                res -= 1\n                prev = [curr[0], min(curr[1], prev[1])]\n            else:\n                prev = curr\n            \n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Sorting\" and then a combination of \"Two Pointers\" and \"Greedy\"."
  },
  {
    "title": "132 Pattern",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def find132pattern(self, nums: List[int]) -> bool:\n        stack = [] # pair [num, curLeftMin], mono-decreasing stack\n        curMin = nums[0]\n\n        for n in nums:\n            while stack and n >= stack[-1][0]:\n                stack.pop()\n            if stack and n < stack[-1][0] and n > stack[-1][1]:\n                return True\n\n            stack.append([n, curMin]) \n            curMin = min(n, curMin)\n\n        return False",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Stack\"."
  },
  {
    "title": "Repeated Substring Pattern",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        return s in (s + s)[1:-1]",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "\"Sliding Window\""
  },
  {
    "title": "Island Perimeter",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\n        visit = set()\n\n        def dfs(i, j):\n            if i >= len(grid) or j >= len(grid[0]) or i < 0 or j < 0 or grid[i][j] == 0:\n                return 1\n            if (i, j) in visit:\n                return 0\n\n            visit.add((i, j))\n            perim = dfs(i, j + 1)\n            perim += dfs(i + 1, j)\n            perim += dfs(i, j - 1)\n            perim += dfs(i - 1, j)\n            return perim\n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j]:\n                    return dfs(i, j)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "dfs",
      "dynamic programming",
      "hash table",
      "recursion"
    ],
    "approach": "DFS (Depth-First Search)"
  },
  {
    "title": "Matchsticks To Square",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def makesquare(self, matchsticks: List[int]) -> bool:\n        length = sum(matchsticks) // 4\n        sides = [0] * 4\n\n        if sum(matchsticks) / 4 != length:\n            return False\n        matchsticks.sort(reverse=True)\n\n        def backtrack(i):\n            if i == len(matchsticks):\n                return True\n\n            for j in range(4):\n                if sides[j] + matchsticks[i] <= length:\n                    sides[j] += matchsticks[i]\n                    if backtrack(i + 1):\n                        return True\n                    sides[j] -= matchsticks[i]\n            return False\n\n        return backtrack(0)",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "Dynamic Programming with Backtracking."
  },
  {
    "title": "Ones And Zeroes",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findMaxForm(self, strs: List[str], M: int, N: int) -> int:\n        dp = defaultdict(int)\n\n        for s in strs:\n            mCnt, nCnt = s.count(\"0\"), s.count(\"1\")\n            for m in range(M, mCnt - 1, -1):\n                for n in range(N, nCnt - 1, -1):\n                    dp[(m, n)] = max(\n                        1 + dp[(m - mCnt, n - nCnt)],\n                        dp[(m, n)])\n        return dp[(M, N)]\n        \n        dp = {}\n\n        def dfs(i, m, n):\n            if i == len(strs):\n                return 0\n            if (i, m, n) in dp:\n                return dp[(i, m, n)]\n            \n            mCnt, nCnt = strs[i].count(\"0\"), strs[i].count(\"1\")\n            dp[(i, m, n)] = dfs(i + 1, m, n)\n            if mCnt <= m and nCnt <= n:\n                dp[(i, m, n)] = max(\n                    dp[(i, m, n)], \n                    1 + dfs(i + 1, m - mCnt, n - nCnt))\n            return dp[(i, m, n)]\n\n        return dfs(0, m, n)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "dynamic programming",
      "hash table",
      "recursion"
    ],
    "approach": "Dynamic Programming (DP)"
  },
  {
    "title": "Target Sum",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        dp = {}  # (index, total) -> # of ways\n\n        def backtrack(i, total):\n            if i == len(nums):\n                return 1 if total == target else 0\n            if (i, total) in dp:\n                return dp[(i, total)]\n\n            dp[(i, total)] = backtrack(i + 1, total + nums[i]) + backtrack(\n                i + 1, total - nums[i]\n            )\n            return dp[(i, total)]\n\n        return backtrack(0, 0)",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "dynamic programming",
      "hash table"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Next Greater Element I",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n\n        nums1Idx = { n:i for i, n in enumerate(nums1) }\n        res = [-1] * len(nums1)\n\n        stack = []\n        for i in range(len(nums2)):\n            cur = nums2[i]\n\n            while stack and cur > stack[-1]:\n                val = stack.pop() # take top val\n                idx = nums1Idx[val]\n                res[idx] = cur\n\n            if cur in nums1Idx:\n                stack.append(cur)\n        \n        return res\n    \n    \n        nums1Idx = { n:i for i, n in enumerate(nums1) }\n        res = [-1] * len(nums1)\n        \n        for i in range(len(nums2)):\n            if nums2[i] not in nums1Idx:\n                continue\n            for j in range(i + 1, len(nums2)):\n                if nums2[j] > nums2[i]:\n                    idx = nums1Idx[nums2[i]]\n                    res[idx] = nums2[j]\n                    break\n        \n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array"
    ],
    "approach": "The main algorithmic approach used is \"Stack\"."
  },
  {
    "title": "Ipo",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\n        maxProfit = [] # only projects we can afford\n        minCapital = [(c, p) for c, p in zip(capital, profits)]\n        heapq.heapify(minCapital)\n\n        for i in range(k):\n            \n            while minCapital and minCapital[0][0] <= w:\n                c, p = heapq.heappop(minCapital)\n                heapq.heappush(maxProfit, -1 * p)\n            if not maxProfit:\n                break\n            w += -1 * heapq.heappop(maxProfit)\n        return w",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Heapq-based Greedy Algorithm"
  },
  {
    "title": "Fibonacci Number",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    Memo = {}\n\n    def fib(self, n: int):\n        if n in self.Memo:\n            return self.Memo[n]\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        self.Memo[n] = self.fib(n - 1) + self.fib(n - 2)\n        return self.Memo[n]",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Find Bottom Left Tree Value",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n\n        res = []\n        q = deque()\n        q.append(root)\n        while q:\n            qlen = len(q)\n            level = []\n            for i in range(qlen):\n                node = q.popleft()\n                if node:\n                    q.append(node.left)\n                    q.append(node.right)\n                    level.append(node.val)\n            if level:\n                res.append(level)\n        return res[-1][0]\n      \nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        max_height = -1\n        res = -1\n        def dfs(root, depth):\n            nonlocal max_height, res\n            if not root:\n                return\n            if depth > max_height:\n                max_height = max(depth, max_height)\n                res = root.val\n            dfs(root.left, depth + 1)\n            dfs(root.right, depth + 1)\n        \n        dfs(root, 0)\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "recursion",
      "tree"
    ],
    "approach": "The main algorithmic approach used is \"Depth-First Search\" (DFS)."
  },
  {
    "title": "Longest Palindromic Subsequence",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def longestPalindromeSubseq(self, s: str) -> int:   \n        dp = [ [0] * (len(s) + 1) for i in range(len(s) + 1)]\n        res = 0\n        \n        for i in range(len(s)):\n            for j in range(len(s) - 1, i - 1, -1):\n                if s[i] == s[j]:\n                    dp[i][j] = 1 if i == j else 2\n                    if i - 1 >= 0:\n                        dp[i][j] += dp[i - 1][j + 1]\n                else:\n                    dp[i][j] = dp[i][j + 1]\n                    if i - 1 >= 0:\n                        dp[i][j] = max(dp[i][j], dp[i - 1][j])\n                res = max(res, dp[i][j])\n        return res\n\n\n        cache = {}\n\n        def dfs(i, j):\n            if i < 0 or j == len(s):\n                return 0\n            if (i, j) in cache:\n                return cache[(i, j)]\n\n            if s[i] == s[j]:\n                length = 1 if i == j else 2\n                cache[(i, j)] = length + dfs(i - 1, j + 1)\n            else:\n                cache[(i, j)] = max(dfs(i - 1, j), dfs(i, j + 1))\n            return cache[(i, j)]\n        \n        for i in range(len(s)):\n            dfs(i, i) # odd length\n            dfs(i, i + 1) # even length\n\n        return max(cache.values())\n        \nclass Solution:\n    def longestPalindromeSubseq(self, s: str) -> int:\n        return self.longestCommonSubsequence(s, s[::-1])\n        \n    \n    def longestCommonSubsequence(self, s1: str, s2: str) -> int:\n        N, M = len(s1), len(s2)\n        dp = [[0] * (M+1) for _ in range(N+1)]\n\n        for i in range(N):\n            for j in range(M):\n                if s1[i] == s2[j]:\n                    dp[i+1][j+1] = 1 + dp[i][j]\n                else:\n                    dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j])\n        return dp[N][M]",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "dfs",
      "dynamic programming",
      "hash table",
      "recursion"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Coin Change Ii",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        cache = {}\n\n        def dfs(i, a):\n            if a == amount:\n                return 1\n            if a > amount:\n                return 0\n            if i == len(coins):\n                return 0\n            if (i, a) in cache:\n                return cache[(i, a)]\n\n            cache[(i, a)] = dfs(i, a + coins[i]) + dfs(i + 1, a)\n            return cache[(i, a)]\n\n        return dfs(0, 0)\n\n        dp = [[0] * (len(coins) + 1) for i in range(amount + 1)]\n        dp[0] = [1] * (len(coins) + 1)\n        for a in range(1, amount + 1):\n            for i in range(len(coins) - 1, -1, -1):\n                dp[a][i] = dp[a][i + 1]\n                if a - coins[i] >= 0:\n                    dp[a][i] += dp[a - coins[i]][i]\n        return dp[amount][0]\n\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n        for i in range(len(coins) - 1, -1, -1):\n            nextDP = [0] * (amount + 1)\n            nextDP[0] = 1\n\n            for a in range(1, amount + 1):\n                nextDP[a] = dp[a]\n                if a - coins[i] >= 0:\n                    nextDP[a] += nextDP[a - coins[i]]\n            dp = nextDP\n        return dp[amount]",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "dfs",
      "dynamic programming",
      "hash table",
      "recursion"
    ],
    "approach": "Dynamic Programming (DP)"
  },
  {
    "title": "Continuous Subarray Sum",
    "description": "No description available.",
    "optimal_code": "\nclass Solution:\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\n        hashmap = {}\n        hashmap[0]=-1\n        summ=0\n        for i,j in enumerate(nums):\n            summ+=j\n            if summ%k in hashmap.keys():\n                if i-hashmap[summ%k]>=2:\n                    return True\n                else:\n                    continue\n            hashmap[summ%k]=i\n        return False",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table",
      "math"
    ],
    "approach": "Hash Map"
  },
  {
    "title": "Contiguous Array",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findMaxLength(self, nums: List[int]) -> int:\n        zero, one = 0, 0\n        res = 0\n\n        diff_index = {}\n\n        for i, n in enumerate(nums):\n            if n == 0:\n                zero += 1\n            else:\n                one += 1\n            if one - zero not in diff_index:\n                diff_index[one - zero] = i\n            \n            if one == zero:\n                res = one + zero\n            else:\n                idx = diff_index[one - zero]\n                res = max(res, i - idx)\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Encode And Decode Tinyurl",
    "description": "No description available.",
    "optimal_code": "class Codec:\n    def __init__(self):\n        self.encodeMap = {}\n        self.decodeMap = {}\n        self.base = \"http://tinyurl.com/\"\n\n    def encode(self, longUrl: str) -> str:\n        \"\"\"Encodes a URL to a shortened URL.\n        \"\"\"\n        if longUrl not in self.encodeMap: \n            shortUrl = self.base + str(len(self.encodeMap) + 1)\n            self.encodeMap[longUrl] = shortUrl\n            self.decodeMap[shortUrl] = longUrl\n        return self.encodeMap[longUrl]\n\n    def decode(self, shortUrl: str) -> str:\n        \"\"\"Decodes a shortened URL to its original URL.\n        \"\"\"\n        return self.decodeMap[shortUrl]",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "hash table",
      "math"
    ],
    "approach": "Hash Map"
  },
  {
    "title": "Single Element In A Sorted Array",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        def is_non_duplicate(i):\n            is_left_different = i == 0 or nums[i-1] != nums[i]\n            is_right_different = i == len(nums)-1 or nums[i+1] != nums[i]\n            return is_left_different and is_right_different\n\n        if len(nums) == 1:\n            return nums[0]\n\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if is_non_duplicate(mid):\n                return nums[mid]\n\n            if mid % 2 == 0:\n                if nums[mid+1] == nums[mid]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            else:\n                if nums[mid+1] == nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1",
    "time_complexity": "O(log n)",
    "space_complexity": "O(1)",
    "tags": [
      "binary search",
      "math"
    ],
    "approach": "Binary Search"
  },
  {
    "title": "Diameter Of Binary Tree",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        res = 0\n\n        def dfs(root):\n            nonlocal res\n\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            res = max(res, left + right)\n\n            return 1 + max(left, right)\n\n        dfs(root)\n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "recursion",
      "tree"
    ],
    "approach": "The main algorithmic approach used is \"Depth-First Search\" (DFS)."
  },
  {
    "title": "Brick Wall",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def leastBricks(self, wall: List[List[int]]) -> int:\n        countGap = { 0 : 0 }    # { Position : Gap count }\n\n        for r in wall:\n            total = 0   # Position\n            for b in r[:-1]:\n                total += b\n                countGap[total] = 1 + countGap.get(total, 0)\n\n        return len(wall) - max(countGap.values())    # Total number of rows - Max gap",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Hash Map"
  },
  {
    "title": "Subarray Sum Equals K",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def subarraySum(self, nums: List[int], k: int) -> int:\n        count = 0\n        sum = 0\n        dic = {}\n        dic[0] = 1\n        for i in range(len(nums)):\n            sum += nums[i]\n            if sum-k in dic:\n                count += dic[sum-k]\n            dic[sum] = dic.get(sum, 0)+1\n        return count",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "hash table"
    ],
    "approach": "Hash Map"
  },
  {
    "title": "Permutation In String",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        if len(s1) > len(s2):\n            return False\n\n        s1Count, s2Count = [0] * 26, [0] * 26\n        for i in range(len(s1)):\n            s1Count[ord(s1[i]) - ord(\"a\")] += 1\n            s2Count[ord(s2[i]) - ord(\"a\")] += 1\n\n        matches = 0\n        for i in range(26):\n            matches += 1 if s1Count[i] == s2Count[i] else 0\n\n        l = 0\n        for r in range(len(s1), len(s2)):\n            if matches == 26:\n                return True\n\n            index = ord(s2[r]) - ord(\"a\")\n            s2Count[index] += 1\n            if s1Count[index] == s2Count[index]:\n                matches += 1\n            elif s1Count[index] + 1 == s2Count[index]:\n                matches -= 1\n\n            index = ord(s2[l]) - ord(\"a\")\n            s2Count[index] -= 1\n            if s1Count[index] == s2Count[index]:\n                matches += 1\n            elif s1Count[index] - 1 == s2Count[index]:\n                matches -= 1\n            l += 1\n        return matches == 26",
    "time_complexity": "O(log n)",
    "space_complexity": "O(1)",
    "tags": [
      "array",
      "binary search"
    ],
    "approach": "The main algorithmic approach used is \"Two Pointers\"."
  },
  {
    "title": "Subtree Of Another Tree",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        if not subRoot:\n            return True\n        if not root:\n            return False\n\n        if self.isSameTree(root, subRoot):\n            return True\n        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\n\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if p and q and p.val == q.val:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n        else:\n            return False",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "tree"
    ],
    "approach": "Divide and Conquer"
  },
  {
    "title": "Can Place Flowers",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        empty = 0 if flowerbed[0] else 1\n\n        for f in flowerbed:\n           if f:\n               n -= int((empty - 1) / 2)  # int division, round toward zero\n               empty = 0\n           else:\n               empty += 1\n\n        n -= (empty) // 2\n        return n <= 0\n        \nclass Solution2:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n       for i in range(len(flowerbed)):\n            if n == 0:\n                return True\n            if ((i == 0 or flowerbed[i - 1] == 0)   # If at the first element or the previous element equals to 0\n                and (flowerbed[i] == 0)             # If current element equals to 0\n                and (i == len(flowerbed) - 1 or flowerbed[i + 1] == 0)): # If at the last element or the next element equals to 0\n                flowerbed[i] = 1\n                n -= 1\n\n       return n == 0\n       \nclass Solution3:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n       f = [0] + flowerbed + [0]\n       \n       for i in range(1, len(f) - 1):  # skip first & last\n           if f[i - 1] == 0 and f[i] == 0 and f[i + 1] == 0:\n               f[i] = 1\n               n -= 1\n       return n <= 0",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "array",
      "math"
    ],
    "approach": "The main algorithmic approach used in these solutions is \"Two Pointers\"."
  },
  {
    "title": "Construct String From Binary Tree",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def tree2str(self, root: Optional[TreeNode]) -> str:\n        res = []\n        self.dfs(root, res)\n        return \"\".join(res)\n\n    def dfs(self, t: TreeNode, res: list):\n        if t is None:\n            return\n        res.append(str(t.val))\n\n        if t.left is None and t.right is None:\n            return\n        res.append('(')\n\n        self.dfs(t.left, res)\n        res.append(')')\n\n        if t.right is not None:\n            res.append('(')\n\n            self.dfs(t.right, res)\n            res.append(')')",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "recursion",
      "tree"
    ],
    "approach": "Depth-First Search (DFS)."
  },
  {
    "title": "Merge Two Binary Trees",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:\n        if not t1 and not t2:\n            return None\n\n        v1 = t1.val if t1 else 0\n        v2 = t2.val if t2 else 0\n        root = TreeNode(v1 + v2)\n\n        root.left = self.mergeTrees(t1.left if t1 else None, t2.left if t2 else None)\n        root.right = self.mergeTrees(t1.right if t1 else None, t2.right if t2 else None)\n        return root",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "tree"
    ],
    "approach": "Recursive DFS."
  },
  {
    "title": "Task Scheduler",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def leastInterval(self, tasks: List[str], n: int) -> int:\n        count = Counter(tasks)\n        maxHeap = [-cnt for cnt in count.values()]\n        heapq.heapify(maxHeap)\n\n        time = 0\n        q = deque()  # pairs of [-cnt, idleTime]\n        while maxHeap or q:\n            time += 1\n\n            if not maxHeap:\n                time = q[0][1]\n            else:\n                cnt = 1 + heapq.heappop(maxHeap)\n                if cnt:\n                    q.append([cnt, time + n])\n            if q and q[0][1] == time:\n                heapq.heappush(maxHeap, q.popleft()[0])\n        return time\n\n\nclass Solution(object):\n    def leastInterval(self, tasks: List[str], n: int) -> int:\n        counter = collections.Counter(tasks)\n        max_count = max(counter.values())\n        min_time = (max_count - 1) * (n + 1) + \\\n                    sum(map(lambda count: count == max_count, counter.values()))\n    \n        return max(min_time, len(tasks))",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Dynamic Programming\"."
  },
  {
    "title": "Design Circular Queue",
    "description": "No description available.",
    "optimal_code": "class Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.next = None\n\n\nclass MyCircularQueue:\n\n    def __init__(self, k: int):\n        self.head = self.tail = None\n        self.capacity = k\n        self.size = 0\n\n\n    def enQueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n\n        node = Node(value)\n        if self.size == 0:\n            self.head = self.tail = node\n        else:\n            self.tail.next = self.tail = node\n\n        self.size += 1\n\n        return True\n\n\n    def deQueue(self) -> bool:\n        if self.isEmpty():\n            return False\n\n        self.head = self.head.next\n        self.size -= 1\n\n        return True\n\n\n    def Front(self) -> int:\n        return -1 if self.isEmpty() else self.head.val\n\n\n    def Rear(self) -> int:\n        return -1 if self.isEmpty() else self.tail.val\n\n\n    def isEmpty(self) -> bool:\n        return self.size == 0\n\n\n    def isFull(self) -> bool:\n        return self.capacity == self.size",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used here is \"Linked List\"."
  },
  {
    "title": "Palindromic Substrings",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def countSubstrings(self, s: str) -> int:\n        res = 0\n\n        for i in range(len(s)):\n            res += self.countPali(s, i, i)\n            res += self.countPali(s, i, i + 1)\n        return res\n\n    def countPali(self, s, l, r):\n        res = 0\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            res += 1\n            l -= 1\n            r += 1\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "array"
    ],
    "approach": "\"Dynamic Programming\""
  },
  {
    "title": "Find K Closest Elements",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:\n        l, r = 0, len(arr) - 1\n\n        val, idx = arr[0], 0\n        while l <= r:\n            m = (l + r) // 2\n            curDiff, resDiff = abs(arr[m] - x), abs(val - x)\n            if curDiff < resDiff or (curDiff == resDiff and arr[m] < val):\n                val, idx = arr[m], m\n\n            if arr[m] < x:\n                l = m + 1\n            elif arr[m] > x:\n                r = m - 1\n            else:\n                break\n\n        l = r = idx\n        for i in range(k - 1):\n            if l == 0:\n                r += 1\n            elif r == len(arr) - 1 or x - arr[l - 1] <= arr[r + 1] - x:\n                l -= 1\n            else:\n                r += 1\n        return arr[l : r + 1]\n\n\nclass Solution:\n    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:\n        l, r = 0, len(arr) - k\n\n        while l < r:\n            m = (l + r) // 2\n            if x - arr[m] > arr[m + k] - x:\n                l = m + 1\n            else:\n                r = m\n        return arr[l : l + k]",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "math",
      "sliding window",
      "two pointers"
    ],
    "approach": "Binary Search."
  },
  {
    "title": "Maximum Width Of Binary Tree",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n\n        q = [(root, 0)]\n        width = 0\n        while q:\n            leftIndex = q[0][1]\n            rightIndex = q[-1][1]\n            width = max(width, rightIndex - leftIndex + 1)\n\n            for _ in range(len(q)):\n                node, index = q.pop(0)\n                if node.left:\n                    q.append((node.left, index * 2))\n                if node.right:\n                    q.append((node.right, index * 2 + 1))\n        return width",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "array",
      "tree"
    ],
    "approach": "\"BFS\" (Breadth-First Search)"
  },
  {
    "title": "Non Decreasing Array",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def checkPossibility(self, nums):\n        if len(nums) <= 2:\n            return True\n        changed = False\n        for i, num in enumerate(nums):\n            if i == len(nums) - 1 or num <= nums[i + 1]:\n                continue\n            if changed:\n                return False\n            if i == 0 or nums[i + 1] >= nums[i - 1]:\n                nums[i] = nums[i + 1]\n            else:\n                nums[i + 1] = nums[i]\n            changed = True\n        return True",
    "time_complexity": "O(log n)",
    "space_complexity": "O(1)",
    "tags": [
      "binary search"
    ],
    "approach": "Greedy"
  },
  {
    "title": "Trim A Binary Search Tree",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:\n        if not root:\n            return None\n\n        if root.val > high:\n            return self.trimBST(root.left, low, high)\n\n        if root.val < low:\n            return self.trimBST(root.right, low, high)\n\n        else:\n            root.left = self.trimBST(root.left, low, high)\n            root.right = self.trimBST(root.right, low, high)\n            return root",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "tree"
    ],
    "approach": "Recursion"
  },
  {
    "title": "Number Of Longest Increasing Subsequence",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n\n        dp = {}  # key = index, value = [length of LIS, count]\n        lenLIS, res = 0, 0  # length of LIS, count of LIS\n\n        def dfs(i):\n            if i in dp:\n                return dp[i]\n\n            maxLen, maxCnt = 1, 1  # length and count of LIS\n            for j in range(i + 1, len(nums)):\n                if nums[j] > nums[i]:  # make sure increasing order\n                    length, count = dfs(j)\n                    if length + 1 > maxLen:\n                        maxLen, maxCnt = length + 1, count\n                    elif length + 1 == maxLen:\n                        maxCnt += count\n            nonlocal lenLIS, res\n            if maxLen > lenLIS:\n                lenLIS, res = maxLen, maxCnt\n            elif maxLen == lenLIS:\n                res += maxCnt\n            dp[i] = [maxLen, maxCnt]\n            return dp[i]\n\n        for i in range(len(nums)):\n            dfs(i)\n        return res\n\n\n        dp = {}  # key = index, value = [length of LIS, count]\n        lenLIS, res = 0, 0  # length of LIS, count of LIS\n\n        for i in range(len(nums) - 1, -1, -1):\n            maxLen, maxCnt = 1, 1  # len, cnt of LIS start from i\n\n            for j in range(i + 1, len(nums)):\n                if nums[j] > nums[i]:\n                    length, count = dp[j]  # len, cnt of LIS start from j\n                    if length + 1 > maxLen:\n                        maxLen, maxCnt = length + 1, count\n                    elif length + 1 == maxLen:\n                        maxCnt += count\n            if maxLen > lenLIS:\n                lenLIS, res = maxLen, maxCnt\n            elif maxLen == lenLIS:\n                res += maxCnt\n            dp[i] = [maxLen, maxCnt]\n\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "dfs",
      "dynamic programming",
      "hash table",
      "recursion"
    ],
    "approach": "The main algorithmic approach used is Dynamic Programming (DP)."
  },
  {
    "title": "Valid Parenthesis String",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def checkValidString(self, s: str) -> bool:\n        dp = {(len(s), 0): True}  # key=(i, leftCount) -> isValid\n\n        def dfs(i, left):\n            if i == len(s) or left < 0:\n                return left == 0\n            if (i, left) in dp:\n                return dp[(i, left)]\n\n            if s[i] == \"(\":\n                dp[(i, left)] = dfs(i + 1, left + 1)\n            elif s[i] == \")\":\n                dp[(i, left)] = dfs(i + 1, left - 1)\n            else:\n                dp[(i, left)] = (\n                    dfs(i + 1, left + 1) or dfs(i + 1, left - 1) or dfs(i + 1, left)\n                )\n            return dp[(i, left)]\n\n        return dfs(0, 0)\n\n\nclass Solution:\n    def checkValidString(self, s: str) -> bool:\n        leftMin, leftMax = 0, 0\n\n        for c in s:\n            if c == \"(\":\n                leftMin, leftMax = leftMin + 1, leftMax + 1\n            elif c == \")\":\n                leftMin, leftMax = leftMin - 1, leftMax - 1\n            else:\n                leftMin, leftMax = leftMin - 1, leftMax + 1\n            if leftMax < 0:\n                return False\n            if leftMin < 0:  # required because -> s = ( * ) (\n                leftMin = 0\n        return leftMin == 0",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "dfs",
      "dynamic programming",
      "recursion"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Valid Palindrome Ii",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def validPalindrome(self, s: str) -> bool:\n        i, j = 0, len(s) - 1\n        \n        while i < j:\n            if s[i] == s[j]:\n                i += 1\n                j -= 1\n            else:\n                return self.validPalindromeUtil(s, i + 1, j) or self.validPalindromeUtil(s, i, j - 1)\n        return True\n    \n    def validPalindromeUtil(self, s, i, j):\n        while i < j:\n            if s[i] == s[j]:\n                i += 1\n                j -= 1\n            else:\n                return False\n        \n        return True",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "dynamic programming"
    ],
    "approach": "\"Divide and Conquer\" or more specifically \"Recursion\"."
  },
  {
    "title": "Baseball Game",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        \n        score_stack = []\n        \n        for o in operations:\n            \n            if o == \"+\" and len(score_stack) >= 2:\n                summed = score_stack[-2] + score_stack[-1]\n                score_stack.append(summed)\n                \n            elif o == \"D\" and len(score_stack) >= 1:\n                doubled = score_stack[-1] * 2\n                score_stack.append(doubled)\n                \n            elif o == \"C\" and len(score_stack) >= 1:\n                score_stack.pop() \n                \n            else: \n                score_stack.append(int(o))\n\n        return sum(score_stack)",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used is: Dynamic Programming"
  },
  {
    "title": "Redundant Connection",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        par = [i for i in range(len(edges) + 1)]\n        rank = [1] * (len(edges) + 1)\n\n        def find(n):\n            p = par[n]\n            while p != par[p]:\n                par[p] = par[par[p]]\n                p = par[p]\n            return p\n\n        def union(n1, n2):\n            p1, p2 = find(n1), find(n2)\n\n            if p1 == p2:\n                return False\n            if rank[p1] > rank[p2]:\n                par[p2] = p1\n                rank[p1] += rank[p2]\n            else:\n                par[p1] = p2\n                rank[p2] += rank[p1]\n            return True\n\n        for n1, n2 in edges:\n            if not union(n1, n2):\n                return [n1, n2]",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "array"
    ],
    "approach": "Union-Find (also known as Disjoint Set)"
  },
  {
    "title": "Max Area Of Island",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        visit = set()\n\n        def dfs(r, c):\n            if (\n                r < 0\n                or r == ROWS\n                or c < 0\n                or c == COLS\n                or grid[r][c] == 0\n                or (r, c) in visit\n            ):\n                return 0\n            visit.add((r, c))\n            return 1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) + dfs(r, c - 1)\n\n        area = 0\n        for r in range(ROWS):\n            for c in range(COLS):\n                area = max(area, dfs(r, c))\n        return area",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "hash table",
      "recursion"
    ],
    "approach": "DFS (Depth-First Search)"
  },
  {
    "title": "Partition To K Equal Sum Subsets",
    "description": "No description available.",
    "optimal_code": "class Solution(object):\n    def canPartitionKSubsets(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n\n        if sum(nums) % k != 0:\n            return False\n\n        nums.sort(reverse = True)\n        target = sum(nums) / k\n        visited= set()\n\n        def backtrack(idx, count, currSum):\n            if count == k:\n                return True\n\n            if target == currSum:\n                return backtrack(0, count + 1, 0)\n\n            for i in range(idx, len(nums)):\n                \n                if i > 0 and (i - 1) not in visited and nums[i] == nums[i - 1]:\n                    continue\n\n                if i in visited or currSum + nums[i] > target:\n                    continue\n\n                visited.add(i)\n\n                if backtrack(i + 1, count, currSum + nums[i]):\n                    return True\n                \n                visited.remove(i)\n\n            return False\n\n\n        return backtrack(0, 0, 0)",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table",
      "math"
    ],
    "approach": "Dynamic Programming with Backtracking"
  },
  {
    "title": "Insert Into A Binary Search Tree",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\n        if not root:\n            return TreeNode(val)\n        if val > root.val:\n            root.right = self.insertIntoBST(root.right, val)\n        else:\n            root.left = self.insertIntoBST(root.left, val)\n        return root",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "tree"
    ],
    "approach": "\"Recursive Binary Tree Traversal\""
  },
  {
    "title": "Kth Largest Element In A Stream",
    "description": "No description available.",
    "optimal_code": "class KthLargest:\n    def __init__(self, k: int, nums: List[int]):\n        self.minHeap, self.k = nums, k\n        heapq.heapify(self.minHeap)\n        while len(self.minHeap) > k:\n            heapq.heappop(self.minHeap)\n\n    def add(self, val: int) -> int:\n        heapq.heappush(self.minHeap, val)\n        if len(self.minHeap) > self.k:\n            heapq.heappop(self.minHeap)\n        return self.minHeap[0]",
    "time_complexity": "O(log n)",
    "space_complexity": "O(1)",
    "tags": [
      "binary search"
    ],
    "approach": "\"Heap\" or \"Priority Queue\""
  },
  {
    "title": "Binary Search",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            m = l + ((r - l) // 2)  # (l + r) // 2 can lead to overflow\n            if nums[m] > target:\n                r = m - 1\n            elif nums[m] < target:\n                l = m + 1\n            else:\n                return m\n        return -1",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "Binary Search"
  },
  {
    "title": "Design Hashset",
    "description": "No description available.",
    "optimal_code": "class MyHashSet:\n\n    def __init__(self):\n        self.hashset = []\n\n    def add(self, key: int) -> None:\n        if not self.contains(key):\n            self.hashset.append(key)\n\n    def remove(self, key: int) -> None:\n        if self.contains(key):\n            self.hashset.remove(key)\n\n    def contains(self, key: int) -> bool:\n        return True if key in self.hashset else False",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Hash Map"
  },
  {
    "title": "Design Hashmap",
    "description": "No description available.",
    "optimal_code": "class ListNode:\n    def __init__(self, key=-1, val=-1, next=None):\n        self.key = key\n        self.val = val\n        self.next = next\n\nclass MyHashMap:\n    def __init__(self):\n        self.map = [ListNode() for i in range(1000)]\n        \n    def hashcode(self, key):\n        return key % len(self.map)\n\n    def put(self, key: int, value: int) -> None:\n        cur = self.map[self.hashcode(key)]\n        while cur.next:\n            if cur.next.key == key:\n                cur.next.val = value\n                return\n            cur = cur.next\n        cur.next = ListNode(key, value)\n         \n    def get(self, key: int) -> int:\n        cur = self.map[self.hashcode(key)].next\n        while cur and cur.key != key:\n            cur = cur.next\n        if cur:\n            return cur.val\n        return -1\n\n    def remove(self, key: int) -> None:\n        cur = self.map[self.hashcode(key)]\n        while cur.next and cur.next.key != key:\n            cur = cur.next\n        if cur and cur.next:\n            cur.next = cur.next.next",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "linked list",
      "math"
    ],
    "approach": "Hash Map"
  },
  {
    "title": "Design Linked List",
    "description": "No description available.",
    "optimal_code": "class ListNode:\n    def __init__(self, val):\n        self.val = val\n        self.prev = None\n        self.next = None\n\nclass MyLinkedList:\n\n    def __init__(self):\n        self.left = ListNode(0)\n        self.right = ListNode(0)\n        self.left.next = self.right\n        self.right.prev = self.left\n\n    def get(self, index: int) -> int:\n        cur = self.left.next\n        while cur and index > 0:\n            cur = cur.next\n            index -= 1\n        \n        if cur and cur != self.right and index == 0:\n            return cur.val\n        return -1\n\n    def addAtHead(self, val: int) -> None:\n        node, prev, next = ListNode(val), self.left, self.left.next\n        node.next, node.prev = next, prev\n        next.prev = node\n        prev.next = node\n\n    def addAtTail(self, val: int) -> None:\n        node, prev, next = ListNode(val), self.right.prev, self.right\n        node.next, node.prev = next, prev\n        next.prev = node\n        prev.next = node\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        next = self.left.next\n        while next and index > 0:\n            next = next.next\n            index -= 1\n        \n        if next and index == 0:\n            node, prev = ListNode(val), next.prev\n            node.next, node.prev = next, prev\n            next.prev = node\n            prev.next = node\n\n\n    def deleteAtIndex(self, index: int) -> None:\n        node = self.left.next\n        while node and index > 0:\n            node = node.next\n            index -= 1\n        \n        if node and node != self.right and index == 0:\n            node.prev.next = node.next\n            node.next.prev = node.prev",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "linked list"
    ],
    "approach": "Linked List Operations"
  },
  {
    "title": "Accounts Merge",
    "description": "No description available.",
    "optimal_code": "class UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.rank = [1] * n\n    \n    def find(self, x):\n        while x != self.par[x]:\n            self.par[x] = self.par[self.par[x]]\n            x = self.par[x]\n        return x\n    \n    def union(self, x1, x2):\n        p1, p2 = self.find(x1), self.find(x2)\n        if p1 == p2:\n            return False\n        if self.rank[p1] > self.rank[p2]:\n            self.par[p2] = p1\n            self.rank[p1] += self.rank[p2]\n        else:\n            self.par[p1] = p2\n            self.rank[p2] += self.rank[p1]\n        return True\n\nclass Solution:\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\n        uf = UnionFind(len(accounts))\n        emailToAcc = {} # email -> index of acc\n\n        for i, a in enumerate(accounts):\n            for e in a[1:]:\n                if e in emailToAcc:\n                    uf.union(i, emailToAcc[e])\n                else:\n                    emailToAcc[e] = i\n\n        emailGroup = defaultdict(list) # index of acc -> list of emails\n        for e, i in emailToAcc.items():\n            leader = uf.find(i)\n            emailGroup[leader].append(e)\n\n        res = []\n        for i, emails in emailGroup.items():\n            name = accounts[i][0]\n            res.append([name] + sorted(emailGroup[i])) # array concat\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Union-Find (Disjoint Set)"
  },
  {
    "title": "Find Pivot Index",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def pivotIndex(self, nums: List[int]) -> int:\n        total = sum(nums)  # O(n)\n\n        leftSum = 0\n        for i in range(len(nums)):\n            rightSum = total - nums[i] - leftSum\n            if leftSum == rightSum:\n                return i\n            leftSum += nums[i]\n        return -1",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "array"
    ],
    "approach": "\"Two Pointers\""
  },
  {
    "title": "My Calendar I",
    "description": "No description available.",
    "optimal_code": "\nclass MyCalendar:\n\n    def __init__(self):\n        self.calendar = CalendarNode(-1, -1)\n\n    def book(self, start: int, end: int) -> bool:\n\n        def bookHelper(cur, targetStart, targetEnd):\n            if targetStart > cur.end:\n                if not cur.right:\n                    cur.right = CalendarNode(targetStart, targetEnd)\n                    return True\n                return bookHelper(cur.right, targetStart, targetEnd)\n            elif targetEnd < cur.start:\n                if not cur.left:\n                    cur.left = CalendarNode(targetStart, targetEnd)\n                    return True\n                return bookHelper(cur.left, targetStart, targetEnd)\n            return False\n        \n        return bookHelper(self.calendar, start, end-1) # \"end-1\" because \"end\" bound is exclusive (see example 1) \n    \n\n\n\nclass CalendarNode:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n        self.left = None\n        self.right = None",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Binary Search\" with a twist of using recursion to traverse the binary search tree."
  },
  {
    "title": "Asteroid Collision",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def asteroidCollision(self, asteroids: List[int]) -> List[int]:\n        stack = []\n\n        for a in asteroids:\n            while stack and a < 0 and stack[-1] > 0:\n                diff = a + stack[-1]\n                if diff > 0:\n                    a = 0\n                elif diff < 0:\n                    stack.pop()\n                else:\n                    a = 0\n                    stack.pop()\n            if a:\n                stack.append(a)\n\n        return stack",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "\"Greedy\""
  },
  {
    "title": "Daily Temperatures",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        res = [0] * len(temperatures)\n        stack = []  # pair: [temp, index]\n\n        for i, t in enumerate(temperatures):\n            while stack and t > stack[-1][0]:\n                stackT, stackInd = stack.pop()\n                res[stackInd] = i - stackInd\n            stack.append((t, i))\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "Stack"
  },
  {
    "title": "Delete And Earn",
    "description": "No description available.",
    "optimal_code": "class Solution(object):\n    def deleteAndEarn(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n\n        upperLimit = max(nums) + 1 \n        store = [0] * upperLimit\n\n        for num in nums:\n            store[num] += num\n\n        dp = [0] * upperLimit\n\n        dp[1] = 1 * store[1]\n        for i in range(2, upperLimit):\n            dp[i] = max(dp[i - 2] + store[i], dp[i - 1])\n\n        return dp[-1]",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "dynamic programming"
    ],
    "approach": "Dynamic Programming."
  },
  {
    "title": "Network Delay Time",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n        edges = collections.defaultdict(list)\n        for u, v, w in times:\n            edges[u].append((v, w))\n\n        minHeap = [(0, k)]\n        visit = set()\n        t = 0\n        while minHeap:\n            w1, n1 = heapq.heappop(minHeap)\n            if n1 in visit:\n                continue\n            visit.add(n1)\n            t = w1\n\n            for n2, w2 in edges[n1]:\n                if n2 not in visit:\n                    heapq.heappush(minHeap, (w1 + w2, n2))\n        return t if len(visit) == n else -1",
    "time_complexity": "O(log n)",
    "space_complexity": "O(n)",
    "tags": [
      "binary search",
      "hash table"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Prefix And Suffix Search",
    "description": "No description available.",
    "optimal_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}  # Dictionary to store child nodes\n        self.word = -1  # Store the index of the word at this node\n\n\nclass WordFilter:\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n\n        for index, word in enumerate(words):\n            for i in range(len(word) + 1):\n                for j in range(len(word) + 1):\n                    key = word[i:] + '{' + word[:j]\n                    cur = self.root\n                    for c in key:\n                        if c not in cur.children:\n                            cur.children[c] = TrieNode()\n                        cur = cur.children[c]\n                    cur.word = index  # Store the index of the word at this node\n\n    def f(self, pref: str, suff: str) -> int:\n        key = suff + '{' + pref\n        cur = self.root\n        for c in key:\n            if c not in cur.children:\n                return -1  # If combination doesn't exist, return -1\n            cur = cur.children[c]\n        return cur.word  # Return the largest index found for the valid combination",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "hash table"
    ],
    "approach": "Trie (prefix tree)"
  },
  {
    "title": "Min Cost Climbing Stairs",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        for i in range(len(cost) - 3, -1, -1):\n            cost[i] += min(cost[i + 1], cost[i + 2])\n\n        return min(cost[0], cost[1])",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "array"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Open The Lock",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def openLock(self, deadends: List[str], target: str) -> int:\n        if \"0000\" in deadends:\n            return -1\n\n        def children(wheel):\n            res = []\n            for i in range(4):\n                digit = str((int(wheel[i]) + 1) % 10)\n                res.append(wheel[:i] + digit + wheel[i + 1 :])\n                digit = str((int(wheel[i]) + 10 - 1) % 10)\n                res.append(wheel[:i] + digit + wheel[i + 1 :])\n            return res\n\n        q = deque()\n        visit = set(deadends)\n        q.append([\"0000\", 0])  # [wheel, turns]\n        while q:\n            wheel, turns = q.popleft()\n            if wheel == target:\n                return turns\n            for child in children(wheel):\n                if child not in visit:\n                    visit.add(child)\n                    q.append([child, turns + 1])\n        return -1",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table",
      "math"
    ],
    "approach": "Breadth-First Search (BFS) with a hint of Greedy algorithm."
  },
  {
    "title": "Partition Labels",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def partitionLabels(self, S: str) -> List[int]:\n        count = {}\n        res = []\n        i, length = 0, len(S)\n        for j in range(length):\n            c = S[j]\n            count[c] = j\n\n        curLen = 0\n        goal = 0\n        while i < length:\n            c = S[i]\n            goal = max(goal, count[c])\n            curLen += 1\n\n            if goal == i:\n                res.append(curLen)\n                curLen = 0\n            i += 1\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "hash table"
    ],
    "approach": "Greedy"
  },
  {
    "title": "Reorganize String",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def reorganizeString(self, s: str) -> str:\n        count = Counter(s)  # Hashmap, count each char\n        maxHeap = [[-cnt, char] for char, cnt in count.items()]\n        heapq.heapify(maxHeap)  # O(n)\n\n        prev = None\n        res = \"\"\n        while maxHeap or prev:\n            if prev and not maxHeap:\n                return \"\"\n            cnt, char = heapq.heappop(maxHeap)\n            res += char\n            cnt += 1\n\n            if prev:\n                heapq.heappush(maxHeap, prev)\n                prev = None\n            if cnt != 0:\n                prev = [cnt, char]\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "\"Dynamic Programming\""
  },
  {
    "title": "Swim In Rising Water",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        N = len(grid)\n        visit = set()\n        minH = [[grid[0][0], 0, 0]]  # (time/max-height, r, c)\n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n\n        visit.add((0, 0))\n        while minH:\n            t, r, c = heapq.heappop(minH)\n            if r == N - 1 and c == N - 1:\n                return t\n            for dr, dc in directions:\n                neiR, neiC = r + dr, c + dc\n                if (\n                    neiR < 0\n                    or neiC < 0\n                    or neiR == N\n                    or neiC == N\n                    or (neiR, neiC) in visit\n                ):\n                    continue\n                visit.add((neiR, neiC))\n                heapq.heappush(minH, [max(t, grid[neiR][neiC]), neiR, neiC])",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Priority Queue (or Heap-based) Algorithm."
  },
  {
    "title": "Minimum Distance Between Bst Nodes",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def minDiffInBST(self, root: Optional[TreeNode]) -> int:\n        curr_smallest, prev = float(\"inf\"), None\n        \n        def inorder(node):\n            nonlocal curr_smallest, prev\n            if node is None:\n                return\n            \n            inorder(node.left)\n            if prev is not None:\n                curr_smallest = min(curr_smallest, node.val-prev.val)\n            prev = node\n            inorder(node.right)\n\n        inorder(root)\n        return curr_smallest",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "tree"
    ],
    "approach": "Inorder Traversal with Dynamic Programming (Greedy)"
  },
  {
    "title": "Is Graph Bipartite",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isBipartiteBFS(self, graph: List[List[int]]) -> bool:\n        colors = [-1] * len(graph)\n        \n        for i in range(len(graph)):\n            if colors[i] == -1:\n                q = deque([i])\n                colors[i] = 0\n                \n                while q:\n                    node = q.popleft()\n                    \n                    for nbh in graph[node]:\n                        if colors[nbh] == -1:\n                            colors[nbh] = 1 - colors[node]\n                            q.append(nbh)\n                        elif colors[nbh] == colors[node]:\n                            return False  \n        \n        return True\n\n    def isBipartiteDFS(self, graph: List[List[int]]) -> bool:\n        colors = [-1] * len(graph)\n\n        def dfs(node, c):\n            colors[node] = c\n            \n            for nbh in graph[node]:\n                if colors[nbh] == -1:\n                    if not dfs(nbh, 1 - c):\n                        return False\n                elif colors[nbh] == colors[node]:\n                    return False\n            \n            return True\n\n        for i in range(len(graph)):\n            if colors[i] == -1:\n                if not dfs(i, 0):\n                    return False\n        \n        return True",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "array",
      "dfs",
      "recursion"
    ],
    "approach": "The main algorithmic approach used is \"BFS\" (Breadth-First Search) and also \"DFS\" (Depth-First Search) in the second function."
  },
  {
    "title": "Cheapest Flights Within K Stops",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findCheapestPrice(\n        self, n: int, flights: List[List[int]], src: int, dst: int, k: int\n    ) -> int:\n        prices = [float(\"inf\")] * n\n        prices[src] = 0\n\n        for i in range(k + 1):\n            tmpPrices = prices.copy()\n\n            for s, d, p in flights:  # s=source, d=dest, p=price\n                if prices[s] == float(\"inf\"):\n                    continue\n                if prices[s] + p < tmpPrices[d]:\n                    tmpPrices[d] = prices[s] + p\n            prices = tmpPrices\n        return -1 if prices[dst] == float(\"inf\") else prices[dst]",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Custom Sort String",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def customSortString(self, order: str, s: str) -> str:\n        char_count_of_s = {}\n        for i in s:\n            char_count_of_s[i] = char_count_of_s.get(i, 0) + 1\n        \n        satisfied_string = \"\"\n        for char in order:\n            if char in char_count_of_s:\n                satisfied_string += char * char_count_of_s[char]\n                del char_count_of_s[char]\n        \n        for key,val in char_count_of_s.items():\n            satisfied_string += key * val\n\n        return satisfied_string",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Hash Map and Greedy"
  },
  {
    "title": "Find Eventual Safe States",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        n = len(graph)\n        safe = {}\n        res = []\n        def dfs(i):\n            if i in safe:\n                return safe[i]\n            safe[i] = False\n            for nei in graph[i]:\n                if not dfs(nei):\n                    return safe[i]\n            safe[i] = True\n            return safe[i]\n        for i in range(len(graph)):\n            if dfs(i): res.append(i)\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "dfs",
      "hash table",
      "recursion"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Push Dominoes",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def pushDominoes(self, dominoes: str) -> str:\n        dom = list(dominoes)\n        q = collections.deque()\n        for i, d in enumerate(dom):\n            if d != '.':\n                q.append((i, d))\n        \n        while q:\n            i, d = q.popleft()\n\n            if d == 'L' and i > 0 and dom[i - 1] == '.':\n                q.append((i - 1, 'L'))\n                dom[i - 1] = 'L'\n            elif d == 'R':\n                if i + 1 < len(dom) and dom[i + 1] == '.':\n                    if i + 2 < len(dom) and dom[i + 2] == 'L':\n                        q.popleft()\n                    else:\n                        q.append((i + 1, 'R'))\n                        dom[i + 1] = 'R'\n\n        return ''.join(dom)",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "\"Queue-based BFS\""
  },
  {
    "title": "Hand Of Straights",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:\n        if len(hand) % groupSize:\n            return False\n\n        count = {}\n        for n in hand:\n            count[n] = 1 + count.get(n, 0)\n\n        minH = list(count.keys())\n        heapq.heapify(minH)\n        while minH:\n            first = minH[0]\n            for i in range(first, first + groupSize):\n                if i not in count:\n                    return False\n                count[i] -= 1\n                if count[i] == 0:\n                    if i != minH[0]:\n                        return False\n                    heapq.heappop(minH)\n        return True",
    "time_complexity": "O(log n)",
    "space_complexity": "O(n)",
    "tags": [
      "binary search",
      "hash table",
      "math"
    ],
    "approach": "\"Priority Queue\" (specifically, a Heap-based Priority Queue)"
  },
  {
    "title": "Car Fleet",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        pair = [(p, s) for p, s in zip(position, speed)]\n        pair.sort(reverse=True)\n        stack = []\n        for p, s in pair:  # Reverse Sorted Order\n            stack.append((target - p) / s)\n            if len(stack) >= 2 and stack[-1] <= stack[-2]:\n                stack.pop()\n        return len(stack)",
    "time_complexity": "O(log n)",
    "space_complexity": "O(1)",
    "tags": [
      "binary search"
    ],
    "approach": "The main algorithmic approach used is \"Greedy\"."
  },
  {
    "title": "Shortest Subarray With Sum At Least K",
    "description": "No description available.",
    "optimal_code": "import collections\nclass Solution:\n    def shortestSubarray(self, nums: List[int], k: int) -> int:\n        size = len(nums)\n        pre = [0]\n        for i in nums:\n            pre.append(pre[-1] + i)\n\n        ans = size + 1\n        monoq = collections.deque()\n        for i, val in enumerate(pre):\n            while monoq and val <= pre[monoq[-1]]:\n                monoq.pop()\n            while monoq and val - pre[monoq[0]] >= k:\n                ans = min(ans, i - monoq.popleft())\n            \n            monoq.append(i)\n        \n        return ans if ans < size + 1 else -1",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "\"Monotonic Queue\" or \"Monotonic Stack\""
  },
  {
    "title": "Koko Eating Bananas",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        l, r = 1, max(piles)\n        res = r\n\n        while l <= r:\n            k = (l + r) // 2\n\n            totalTime = 0\n            for p in piles:\n                totalTime += math.ceil(float(p) / k)\n            if totalTime <= h:\n                res = k\n                r = k - 1\n            else:\n                l = k + 1\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "math"
    ],
    "approach": "Binary Search."
  },
  {
    "title": "Middle Of The Linked List",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        slow = fast = head\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n\n        return slow",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "linked list"
    ],
    "approach": "Two Pointers"
  },
  {
    "title": "Boats To Save People",
    "description": "No description available.",
    "optimal_code": "class Solution(object):\n    def numRescueBoats(self, people: list[int], limit: int) -> int:\n        people.sort()\n        right = len(people) - 1\n        left = res = 0\n        while left <= right:\n            if people[left] + people[right] <= limit:\n                left += 1\n            right -= 1\n            res += 1\n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "Two Pointers"
  },
  {
    "title": "All Possible Full Binary Trees",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def allPossibleFBT(self, n: int) -> List[Optional[TreeNode]]:\n        dp = { 0 : [], 1 : [ TreeNode() ] }\n\n        def backtrack(n):\n            if n in dp:\n                return dp[n]\n            \n            res = []\n            for l in range(n):\n                r = n - 1 - l\n                leftTrees, rightTrees = backtrack(l), backtrack(r)\n\n                for t1 in leftTrees:\n                    for t2 in rightTrees:\n                        res.append(TreeNode(0, t1, t2))\n            dp[n] = res\n            return res\n        \n        return backtrack(n)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "dynamic programming",
      "tree"
    ],
    "approach": "Dynamic Programming (DP)"
  },
  {
    "title": "Maximum Frequency Stack",
    "description": "No description available.",
    "optimal_code": "class FreqStack:\n    def __init__(self):\n        self.cnt = {}\n        self.maxCnt = 0\n        self.stacks = {}\n\n    def push(self, val: int) -> None:\n        valCnt = 1 + self.cnt.get(val, 0)\n        self.cnt[val] = valCnt\n        if valCnt > self.maxCnt:\n            self.maxCnt = valCnt\n            self.stacks[valCnt] = []\n        self.stacks[valCnt].append(val)\n\n    def pop(self) -> int:\n        res = self.stacks[self.maxCnt].pop()\n        self.cnt[res] -= 1\n        if not self.stacks[self.maxCnt]:\n            self.maxCnt -= 1\n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Monotonic Array",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isMonotonic(self, nums: List[int]) -> bool:\n        increasing = decreasing = True\n        \n        for i in range(len(nums) - 1):\n            if nums[i] > nums[i + 1]:\n                increasing = False\n            if nums[i] < nums[i + 1]:\n                decreasing = False\n        \n        return increasing or decreasing",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "array"
    ],
    "approach": "\"Linear Scan\""
  },
  {
    "title": "Online Stock Span",
    "description": "No description available.",
    "optimal_code": "class StockSpanner:\n    def __init__(self):\n        self.stack = []  # pair: (price, span)\n\n    def next(self, price: int) -> int:\n        span = 1\n        while self.stack and self.stack[-1][0] <= price:\n            span += self.stack[-1][1]\n            self.stack.pop()\n        self.stack.append((price, span))\n        return span",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Stack-based algorithm"
  },
  {
    "title": "Fruit Into Baskets",
    "description": "No description available.",
    "optimal_code": "import collections\n\nclass Solution:\n    def totalFruit(self, fruits: List[int]) -> int:\n        count = collections.defaultdict(int)\n        l, total, res = 0, 0, 0\n\n        for r in range(len(fruits)):\n            count[fruits[r]] += 1\n            total += 1\n\n            while len(count) > 2:\n                f = fruits[l]\n                count[f] -= 1\n                total -= 1\n                l += 1\n                if not count[f]:\n                    count.pop(f)\n\n            res = max(res, total)\n\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "hash table"
    ],
    "approach": "The main algorithmic approach used is: \"Sliding Window\""
  },
  {
    "title": "Fruit Into Baskets",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def totalFruit(self, fruits: List[int]) -> int:\n        tr = {}\n        l = r = 0\n        res = 0\n        while r < len(fruits):\n            if fruits[r] not in tr:\n                tr[fruits[r]] = 1\n            else:\n                tr[fruits[r]] += 1\n            while len(tr) > 2:\n                tr[fruits[l]] -= 1\n                if tr[fruits[l]] == 0:\n                    del tr[fruits[l]]\n                l += 1\n            res = max(res, r-l+1)\n            r += 1\n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "The main algorithmic approach used is \"Sliding Window\" with a twist of using a HashMap (or in this case, a dictionary) to keep track of the fruit types and their counts."
  },
  {
    "title": "Snakes And Ladders",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def snakesAndLadders(self, board: List[List[int]]) -> int:\n        length = len(board)\n        board.reverse()\n\n        def intToPos(square):\n            r = (square - 1) // length\n            c = (square - 1) % length\n            if r % 2:\n                c = length - 1 - c\n            return [r, c]\n\n        q = deque()\n        q.append([1, 0])  # [square, moves]\n        visit = set()\n        while q:\n            square, moves = q.popleft()\n            for i in range(1, 7):\n                nextSquare = square + i\n                r, c = intToPos(nextSquare)\n                if board[r][c] != -1:\n                    nextSquare = board[r][c]\n                if nextSquare == length * length:\n                    return moves + 1\n                if nextSquare not in visit:\n                    visit.add(nextSquare)\n                    q.append([nextSquare, moves + 1])\n        return -1",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table",
      "math"
    ],
    "approach": "\"BFS\" (Breadth-First Search)"
  },
  {
    "title": "Sort An Array",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        def merge(arr, L, M, R):\n            left, right = arr[L:M+1], arr[M+1:R+1]\n            i, j, k = L, 0, 0\n            while j < len(left) and k < len(right):\n                if left[j] <= right[k]:\n                    arr[i] = left[j]\n                    j += 1\n                else:\n                    arr[i] = right[k]\n                    k += 1\n                i += 1\n            while j < len(left):\n                nums[i] = left[j]\n                j += 1\n                i += 1\n            while k < len(right):\n                nums[i] = right[k]\n                k += 1\n                i += 1\n\n        def mergeSort(arr, l, r):\n            if l == r:\n                return arr\n            m = (l + r) // 2\n            mergeSort(arr, l, m)\n            mergeSort(arr, m + 1, r)\n            merge(arr, l, m, r)\n            return arr\n        \n        return mergeSort(nums, 0, len(nums) - 1)",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "Divide and Conquer with Merge Sort."
  },
  {
    "title": "Maximum Sum Circular Subarray",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxSubarraySumCircular(self, nums: List[int]) -> int:\n        globMax, globMin = nums[0], nums[0]\n        curMax, curMin = 0, 0\n        total = 0\n        \n        for i, n in enumerate(nums):\n            curMax = max(curMax + n, n)\n            curMin = min(curMin + n, n)\n            total += n\n            globMax = max(curMax, globMax)\n            globMin = min(curMin, globMin)\n\n        return max(globMax, total - globMin) if globMax > 0 else globMax",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Unique Email Addresses",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def numUniqueEmails(self, emails: list[str]) -> int:\n        unique_emails: set[str] = set()\n        for email in emails:\n            local_name, domain_name = email.split('@')\n            local_name = local_name.split('+')[0]\n            local_name = local_name.replace('.', '')\n            email = local_name + '@' + domain_name\n            unique_emails.add(email)\n        return len(unique_emails)",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "The main algorithmic approach used is \"Hash Map\" and \"String Manipulation\"."
  },
  {
    "title": "Binary Subarrays With Sum",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def numSubarraysWithSum(self, nums: List[int], goal: int) -> int:\n\n        def helper(x):\n            if x < 0: return 0\n\n            res = 0\n            l, cur = 0, 0\n            for r in range(len(nums)):\n                cur += nums[r]\n                while cur > x:\n                    cur -= nums[l]\n                    l += 1\n                res += (r - l + 1)\n            return res\n        \n        return helper(goal) - helper(goal - 1)",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "array"
    ],
    "approach": "Two Pointers"
  },
  {
    "title": "Minimum Falling Path Sum",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        Memo = {}\n\n        def Path(i, k, n):\n            if (i, k) in Memo:\n                return Memo[(i, k)]\n            if i == n - 1:\n                return matrix[i][k]\n            if k > 0 and k < n - 1:\n                Psx = matrix[i][k] + Path(i + 1, k - 1, n)\n                Pst = matrix[i][k] + Path(i + 1, k, n)\n                Pdx = matrix[i][k] + Path(i + 1, k + 1, n)\n                Memo[(i, k)] = min(min(Pdx, Pst), Psx)\n                return Memo[(i, k)]\n            else:\n                if k == 0:\n                    Pst = matrix[i][k] + Path(i + 1, k, n)\n                    Pdx = matrix[i][k] + Path(i + 1, k + 1, n)\n                    Memo[(i, k)] = min(Pst, Pdx)\n                    return Memo[(i, k)]\n                else:\n                    Psx = matrix[i][k] + Path(i + 1, k - 1, n)\n                    Pst = matrix[i][k] + Path(i + 1, k, n)\n                    Memo[(i, k)] = min(Pst, Psx)\n                    return Memo[(i, k)]\n\n        Min = 10**7\n        for k in range(0, len(matrix[0])):\n            CP = Path(0, k, len(matrix[0]))\n            if CP < Min:\n                Min = CP\n        return Min",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Validate Stack Sequences",
    "description": "No description available.",
    "optimal_code": "class Solution(object):\n    def validateStackSequences(self, pushed, popped):\n        i = 0\n        stack = []\n        for n in pushed:\n            stack.append(n)\n            while i < len(popped) and stack and popped[i] == stack[-1]:\n                stack.pop()\n                i += 1\n\n        return not stack",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Two Pointers\"."
  },
  {
    "title": "Bag Of Tokens",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def bagOfTokensScore(self, tokens: List[int], power: int) -> int:\n        res = score = 0\n        tokens.sort()\n\n        l, r = 0, len(tokens) - 1\n        while (l <= r):\n            if power >= tokens[l]:\n                power -= tokens[l]\n                l += 1\n                score += 1\n                res = max(res, score)\n            elif score > 0:\n                power += tokens[r]\n                r -= 1\n                score -= 1\n            else:\n                break\n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "Two Pointers"
  },
  {
    "title": "Verifying An Alien Dictionary",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        orderInd = { c : i for i, c in enumerate(order)}\n        \n        for i in range(len(words) - 1):\n            w1, w2 = words[i], words[i + 1]\n            \n            for j in range(len(w1)):\n                if j == len(w2):\n                    return False\n                \n                if w1[j] != w2[j]:\n                    if orderInd[w2[j]] < orderInd[w1[j]]:\n                        return False\n                    break\n        return True",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "array"
    ],
    "approach": "The main algorithmic approach used is \"Greedy\"."
  },
  {
    "title": "K Closest Points To Origin",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        minHeap = []\n        for x, y in points:\n            dist = (x ** 2) + (y ** 2)\n            minHeap.append((dist, x, y))\n        \n        heapq.heapify(minHeap)\n        res = []\n        for _ in range(k):\n            _, x, y = heapq.heappop(minHeap)\n            res.append((x, y))\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "\"Heap\" or \"Priority Queue\"."
  },
  {
    "title": "Squares Of A Sorted Array",
    "description": "No description available.",
    "optimal_code": "\nclass Solution:\n    def sortedSquares(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        res = [0] * n\n        l, r = 0, n - 1\n        \n        while l <= r:\n            left, right = abs(nums[l]), abs(nums[r])\n            if left > right:\n                res[r - l] = left * left\n                l += 1\n            else:\n                res[r - l] = right * right\n                r -= 1\n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "Two Pointers"
  },
  {
    "title": "Longest Turbulent Subarray",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\n        l, r = 0, 1\n        res, prev = 1, \"\"\n\n        while r < len(arr):\n            if arr[r - 1] > arr[r] and prev != \">\":\n                res = max(res, r - l + 1)\n                r += 1\n                prev = \">\"\n            elif arr[r - 1] < arr[r] and prev != \"<\":\n                res = max(res, r - l + 1)\n                r += 1\n                prev = \"<\"\n            else:\n                r = r + 1 if arr[r] == arr[r - 1] else r\n                l = r - 1\n                prev = \"\"\n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "Greedy"
  },
  {
    "title": "Time Based Key Value Store",
    "description": "No description available.",
    "optimal_code": "class TimeMap:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.keyStore = {}  # key : list of [val, timestamp]\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        if key not in self.keyStore:\n            self.keyStore[key] = []\n        self.keyStore[key].append([value, timestamp])\n\n    def get(self, key: str, timestamp: int) -> str:\n        res, values = \"\", self.keyStore.get(key, [])\n        l, r = 0, len(values) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if values[m][1] <= timestamp:\n                res = values[m][0]\n                l = m + 1\n            else:\n                r = m - 1\n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "hash table",
      "math"
    ],
    "approach": "\"Binary Search\""
  },
  {
    "title": "Rotting Oranges",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        q = collections.deque()\n        fresh = 0\n        time = 0\n\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == 1:\n                    fresh += 1\n                if grid[r][c] == 2:\n                    q.append((r, c))\n\n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n        while fresh > 0 and q:\n            length = len(q)\n            for i in range(length):\n                r, c = q.popleft()\n\n                for dr, dc in directions:\n                    row, col = r + dr, c + dc\n                    if (\n                        row in range(len(grid))\n                        and col in range(len(grid[0]))\n                        and grid[row][col] == 1\n                    ):\n                        grid[row][col] = 2\n                        q.append((row, col))\n                        fresh -= 1\n            time += 1\n        return time if fresh == 0 else -1",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "array"
    ],
    "approach": "BFS (Breadth-First Search)"
  },
  {
    "title": "Find The Town Judge",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        delta = defaultdict(int)\n\n        for src, dst in trust:\n            delta[src] -= 1\n            delta[dst] += 1\n\n        for i in range(1, n + 1):\n            if delta[i] == n - 1:\n                return i\n        return -1",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "\"Hash Map\" and \"Simple Iteration\"."
  },
  {
    "title": "Capacity To Ship Packages Within D Days",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def shipWithinDays(self, weights: List[int], days: int) -> int:\n        l, r = max(weights), sum(weights)\n        min_cap = r\n\n        def canShip(cap):\n            ships, curCap = 1, cap\n            for w in weights:\n                if curCap - w < 0:\n                    ships += 1\n                    curCap = cap\n                curCap -= w\n            return ships <= days\n\n        while l <= r:\n            cap = (l + r) // 2\n            if canShip(cap):\n                min_cap = min(min_cap, cap)\n                r = cap - 1\n            else:\n                l = cap + 1\n\n        return min_cap",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "Binary Search"
  },
  {
    "title": "Number Of Enclaves",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def numEnclaves(self, grid: List[List[int]]) -> int:\n\n        ROWS, COLS = len(grid), len(grid[0])\n\n        def dfs(grid, row, col):\n            if 0 <= row < ROWS and 0 <= col < COLS:\n                if grid[row][col] == 1:\n                    grid[row][col] = 0\n                    dfs(grid, row + 1, col)\n                    dfs(grid, row - 1, col)\n                    dfs(grid, row, col + 1)\n                    dfs(grid, row, col - 1)\n               \n        for row in range(ROWS):\n            dfs(grid, row, 0)\n            dfs(grid, row, COLS - 1)\n\n        for col in range(COLS):\n            dfs(grid, 0, col)\n            dfs(grid, ROWS - 1, col)\n\n        return sum(grid[row][col] == 1 for row in range(ROWS) for col in range(COLS))",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "dfs",
      "recursion"
    ],
    "approach": "DFS (Depth-First Search)"
  },
  {
    "title": "Two City Scheduling",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        diffs = []\n        for c1, c2 in costs:\n            diffs.append([c2 - c1, c1, c2])\n        diffs.sort()\n        res = 0\n        for i in range(len(diffs)):\n            if i < len(diffs) / 2:\n                res += diffs[i][2]\n            else:\n                res += diffs[i][1]\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array"
    ],
    "approach": "Sorting"
  },
  {
    "title": "Last Stone Weight",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        stones = [-s for s in stones]\n        heapq.heapify(stones)\n\n        while len(stones) > 1:\n            first = heapq.heappop(stones)\n            second = heapq.heappop(stones)\n            if second > first:\n                heapq.heappush(stones, first - second)\n\n        stones.append(0)\n        return abs(stones[0])\n\nclass Solution(object):\n    def lastStoneWeight(self, stones):\n        heapq._heapify_max(stones)\n        while len(stones) > 1:\n            max_stone = heapq._heappop_max(stones)\n            diff = max_stone - stones[0]\n            if diff:\n                heapq._heapreplace_max(stones, diff)\n            else:\n                heapq._heappop_max(stones)\n        \n        stones.append(0)\n        return stones[0]",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Heap\"."
  },
  {
    "title": "Last Stone Weight Ii",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        stoneSum = sum(stones)\n        target = ceil(stoneSum / 2)\n\n        def dfs(i, total):\n            if total >= target or i == len(stones):\n                return abs(total - (stoneSum - total))\n            if (i, total) in dp:\n                return dp[(i, total)]\n\n            dp[(i, total)] = min(dfs(i + 1, total),\n                                 dfs(i + 1, total + stones[i]))\n            return dp[(i, total)]\n\n        dp = {}\n        return dfs(0, 0)",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "dynamic programming",
      "hash table",
      "recursion"
    ],
    "approach": "Dynamic Programming (DP)"
  },
  {
    "title": "Number Of Submatrices That Sum To Target",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        sub_sum = [[0 for i in range(COLS)] for j in range(ROWS)]\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                top = sub_sum[r - 1][c] if r > 0 else 0\n                left = sub_sum[r][c - 1] if c > 0 else 0\n                top_left = sub_sum[r - 1][c - 1] if min(r, c) > 0 else 0\n                sub_sum[r][c] = matrix[r][c] + top + left - top_left\n        \n        res = 0\n        for r1 in range(ROWS):\n            for r2 in range(r1, ROWS):\n                count = defaultdict(int) # prefix_sum -> count\n                count[0] = 1\n                for c in range(COLS):\n                    cur_sum = sub_sum[r2][c] - (\n                        sub_sum[r1 - 1][c] if r1 > 0 else 0\n                    )\n                    diff = cur_sum - target\n                    res += count[diff]\n                    count[cur_sum] += 1\n\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Shortest Path In Binary Matrix",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\n        N = len(grid)\n        q = deque([(0, 0, 1)]) # r, c, length\n        visit = set((0, 0))\n        direct = [[0, 1], [1, 0], [0, -1], [-1, 0],\n                  [1, 1], [-1, -1], [1, -1], [-1, 1]]\n        while q:\n            r, c, length = q.popleft()\n            if (min(r, c) < 0 or max(r, c) >= N or\n                grid[r][c]):\n                continue\n            if r == N - 1 and c == N - 1:\n                return length\n            for dr, dc in direct:\n                if (r + dr, c + dc) not in visit:\n                    q.append((r + dr, c + dc, length + 1))\n                    visit.add((r + dr, c + dc))\n        return -1",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Breadth-First Search (BFS)."
  },
  {
    "title": "N Th Tribonacci Number",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    Memo = {}\n\n    def tribonacci(self, n: int):\n        if n in self.Memo:\n            return self.Memo[n]\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 1\n        self.Memo[n] = (\n            self.tribonacci(n - 1) + self.tribonacci(n - 2) + self.tribonacci(n - 3)\n        )\n        return self.Memo[n]",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Longest Common Subsequence",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        dp = [[0 for j in range(len(text2) + 1)] for i in range(len(text1) + 1)]\n\n        for i in range(len(text1) - 1, -1, -1):\n            for j in range(len(text2) - 1, -1, -1):\n                if text1[i] == text2[j]:\n                    dp[i][j] = 1 + dp[i + 1][j + 1]\n                else:\n                    dp[i][j] = max(dp[i][j + 1], dp[i + 1][j])\n\n        return dp[0][0]",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "array",
      "dynamic programming"
    ],
    "approach": "Dynamic Programming."
  },
  {
    "title": "Maximum Number Of Balloons",
    "description": "No description available.",
    "optimal_code": "from collections import Counter\n\n\nclass Solution:\n    def maxNumberOfBalloons(self, text: str) -> int:\n        countText = Counter(text)\n        balloon = Counter(\"balloon\")\n\n        res = len(text)  # or float(\"inf\")\n        for c in balloon:\n            res = min(res, countText[c] // balloon[c])\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "math"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Sort Items By Groups Respecting Dependencies",
    "description": "No description available.",
    "optimal_code": "from collections import defaultdict, deque\nfrom typing import List\nclass Solution:\n    def topologicalSort(self, successors: List[List[int]], predecessors_count: List[int], num_nodes: int) -> List[int]:\n        order = []  # To store the topologically sorted nodes\n        nodes_with_no_predecessors = deque(node for node in range(num_nodes) if not predecessors_count[node])\n        \n        while nodes_with_no_predecessors:  # Process nodes while there are nodes without predecessors\n            node = nodes_with_no_predecessors.popleft()  # Get the node with no predecessors\n            order.append(node)  # Add the node to the sorted order\n            for successor in successors[node]:  # For each successor of the current node\n                predecessors_count[successor] -= 1  # Decrement the in-degree of the successor\n                if not predecessors_count[successor]:  # If the successor now has no predecessors\n                    nodes_with_no_predecessors.append(successor)  # Add it to the queue for processing\n        \n        return order if len(order) == num_nodes else []  # Return the order if all nodes were sorted, else return empty list\n\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        for item in range(n):\n            if group[item] == -1:  # If the item doesn't belong to any group\n                group[item] = m  # Assign a new group ID\n                m += 1  # Increment the group ID for the next item\n        \n        successors_group, successors_item = [[] for _ in range(m)], [[] for _ in range(n)]  # Graphs for group and item dependencies\n        predecessors_count_group, predecessors_count_item = [0] * m, [0] * n  # Count of incoming edges (predecessors) for each group and item\n        \n        for item in range(n):\n            current_group = group[item]  # Get the group of the current item\n            for before in beforeItems[item]:  # Process each item that should come before the current item\n                before_group = group[before]  # Get the group of the item that should come before\n                \n                if current_group == before_group:  # If the two items belong to the same group\n                    successors_item[before].append(item)  # Add a dependency from 'before' to the current item\n                    predecessors_count_item[item] += 1  # Increment the in-degree of the current item\n                else:  # If the items belong to different groups\n                    successors_group[before_group].append(current_group)  # Add a group dependency\n                    predecessors_count_group[current_group] += 1  # Increment the in-degree of the current group\n        \n        groups_order = self.topologicalSort(successors_group, predecessors_count_group, m)  # Topological sort of groups\n        items_order = self.topologicalSort(successors_item, predecessors_count_item, n)  # Topological sort of items\n        \n        if not groups_order or not items_order:\n            return []  # Return an empty list if either the group or item topological sort failed\n        \n        items_grouped = [[] for _ in range(m)]  # Create an empty list for each group to store its items\n        for item in items_order:  # Process each item in topologically sorted order\n            items_grouped[group[item]].append(item)  # Add the item to the appropriate group\n        \n        result = []  # The final result list to store the sorted items\n        for grp in groups_order:  # For each group in topologically sorted order\n            result.extend(items_grouped[grp])  # Add the items of the group to the result\n        \n        return result  # Return the final sorted list of items respecting both item and group dependencies",
    "time_complexity": "O(log n)",
    "space_complexity": "O(n)",
    "tags": [
      "binary search",
      "hash table"
    ],
    "approach": "The main algorithmic approach used is \"Topological Sort\"."
  },
  {
    "title": "Remove All Adjacent Duplicates In String Ii",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        stack = []  # [char, count]\n\n        for c in s:\n            if stack and stack[-1][0] == c:\n                stack[-1][1] += 1\n            else:\n                stack.append([c, 1])\n\n            if stack[-1][1] == k:\n                stack.pop()\n\n        res = \"\"\n        for char, count in stack:\n            res += char * count\n\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "\"Stack\" or \"Greedy\""
  },
  {
    "title": "Count Vowels Permutation",
    "description": "No description available.",
    "optimal_code": "class Solution:    \n    Memo = {}    \n    def countVowelPermutation(self, n, c = '') -> int:        \n        if (c, n) in self.Memo:            \n            return self.Memo[(c, n)]\n        if n == 1:\n            if c == 'a':\n                return 1 \n            if c == 'e':\n                return 2 \n            if c == 'i':\n                return 4 \n            if c == 'o':\n                return 2 \n            if c == 'u':\n                return 1            \n            if c == '':                \n                return 5\n        else:\n            if c == 'a':\n                self.Memo[('a', n)] = self.countVowelPermutation(n - 1, 'e')                \n                return self.Memo[('a', n)]\n            if c == 'e':\n                self.Memo[('e', n)] = self.countVowelPermutation(n - 1, 'a') + self.countVowelPermutation(n - 1, 'i')                \n                return self.Memo[('e', n)]\n            if c == 'i':\n                self.Memo[('i', n)] = self.countVowelPermutation(n - 1, 'a') + self.countVowelPermutation(n - 1, 'e') + self.countVowelPermutation(n - 1, 'o') + self.countVowelPermutation(n - 1, 'u')          \n                return self.Memo[('i', n)]\n            if c == 'o':\n                self.Memo[('o', n)] = self.countVowelPermutation(n - 1, 'i') + self.countVowelPermutation(n - 1, 'u')                \n                return self.Memo[('o', n)]\n            if c == 'u':\n                self.Memo[('u', n)] = self.countVowelPermutation(n - 1, 'a')                \n                return self.Memo[('u', n)]\n            if c == '':\n                Tot = 0\n                for i in ['a', 'e', 'i', 'o', 'u']:\n                    Tot = Tot + self.countVowelPermutation(n - 1, i);                    \n                return Tot % 1000000007",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table",
      "math"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Maximum Length Of A Concatenated String With Unique Characters",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        charSet = set()\n\n        def overlap(charSet, s):\n            c = Counter(charSet) + Counter(s)\n            return max(c.values()) > 1\n\n        def backtrack(i):\n            if i == len(arr):\n                return len(charSet)\n            res = 0\n            if not overlap(charSet, arr[i]):\n                for c in arr[i]:\n                    charSet.add(c)\n                res = backtrack(i + 1)\n                for c in arr[i]:\n                    charSet.remove(c)\n            return max(res, backtrack(i + 1))  # dont concatenate arr[i]\n\n        return backtrack(0)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "The main algorithmic approach used is \"Dynamic Programming\"."
  },
  {
    "title": "Number Of Closed Islands",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        r = len(grid)\n        c = len(grid[0])\n        seen = set()\n\n        def dfs(x, y):\n            if x < 0 or x >= r or y < 0 or y >= c or (x, y) in seen or grid[x][y] == 1:\n                return\n            seen.add((x, y))\n            grid[x][y] = 1\n            dfs(x+1, y)\n            dfs(x, y+1)\n            dfs(x-1, y)\n            dfs(x, y-1)\n        \n        for i in range(r):\n            for j in range(c):\n                if i == 0 or j == 0 or i == r-1 or j == c-1:\n                    dfs(i, j)\n        ans = 0\n        for i in range(r):\n            for j in range(c):\n                if grid[i][j] == 0:\n                    dfs(i, j)\n                    ans += 1\n        return ans",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "dynamic programming",
      "hash table",
      "recursion"
    ],
    "approach": "The main algorithmic approach used is Depth-First Search (DFS)."
  },
  {
    "title": "Shift 2D Grid",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\n        M, N = len(grid), len(grid[0])\n        \n        def posToVal(r, c):\n            return r * N + c\n        def valToPos(v):\n            return [v // N, v % N] # r, c\n        \n        res = [[0] * N for i in range(M)]\n        for r in range(M):\n            for c in range(N):\n                newVal = (posToVal(r, c) + k) % (M * N)\n                newR, newC = valToPos(newVal)\n                res[newR][newC] = grid[r][c]\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "math"
    ],
    "approach": "The main algorithmic approach used is \"Hash Map\" or more accurately, it's a \"Mathematical Transformation\"."
  },
  {
    "title": "Remove Covered Intervals",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: (x[0], -x[1]))\n        \n        covered, maxri = 0, 0\n        \n        for _, ri in intervals:\n            if ri > maxri:\n                maxri = ri\n            else:\n                covered += 1\n                \n        return len(intervals) - covered",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Sorting"
  },
  {
    "title": "Replace Elements With Greatest Element On Right Side",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def replaceElements(self, arr: List[int]) -> List[int]:\n        rightMax = -1\n        for i in range(len(arr) -1, -1, -1):\n            newMax = max(rightMax, arr[i])\n            arr[i] = rightMax\n            rightMax = newMax\n        return arr",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "array"
    ],
    "approach": "Greedy"
  },
  {
    "title": "Number Of Sub Arrays Of Size K And Average Greater Than Or Equal To Threshold",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:\n        res = 0\n        curSum = sum(arr[:k-1])\n\n        for L in range(len(arr) - k + 1):\n            curSum += arr[L + k - 1]\n            if (curSum / k) >= threshold:\n                res += 1\n            curSum -= arr[L]\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "array"
    ],
    "approach": "Sliding Window"
  },
  {
    "title": "Jump Game Iv",
    "description": "No description available.",
    "optimal_code": "\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n < 2:\n            return 0\n        d = defaultdict(list)\n        for i in reversed(range(n)):\n            d[arr[i]].append(i)\n\n        def getUnqueuedNeighbors(i: int) -> List[int]:\n            adj = []\n            if 0 < i and not seen[i - 1]:\n                seen[i - 1] = True\n                adj.append(i - 1)\n            if i < n - 1 and not seen[i + 1]:\n                seen[i + 1] = True\n                adj.append(i + 1)\n            if arr[i] in d:\n                for node in d[arr[i]]:\n                    if node != i:\n                        adj.append(node)\n                        seen[node] = True\n                d.pop(arr[i])\n            return adj\n\n        seen = [False] * n\n        seen[0] = True\n        steps, level = 0, deque([0])\n        while level:\n            steps += 1\n            for _ in range(len(level)):\n                current = level.popleft()\n                for nei in getUnqueuedNeighbors(current):\n                    if nei == n - 1:\n                        return steps\n                    level.append(nei)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "hash table"
    ],
    "approach": "BFS (Breadth-First Search)"
  },
  {
    "title": "Maximum Performance Of A Team",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        mod = 10 ** 9 + 7\n        eng = []\n        for eff, spd in zip(efficiency, speed):\n            eng.append([eff, spd])\n        eng.sort(reverse = True)\n        \n        res, speed = 0, 0\n        minHeap = []\n        \n        for eff, spd in eng:\n            if len(minHeap) == k:\n                speed -= heapq.heappop(minHeap)\n            speed += spd\n            heapq.heappush(minHeap, spd)\n            res = max(res, eff * speed)\n        return res % mod",
    "time_complexity": "O(log n)",
    "space_complexity": "O(n)",
    "tags": [
      "binary search",
      "math"
    ],
    "approach": "The main algorithmic approach used is \"Priority Queue\" (more specifically, a min-heap)."
  },
  {
    "title": "Design Underground System",
    "description": "No description available.",
    "optimal_code": "class UndergroundSystem:\n    def __init__(self):\n        self.customer = {}\n        \n        self.time = {}\n\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\n        self.customer[id] = (stationName, t)\n\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\n        start, time = self.customer[id]\n        route = (start, stationName)\n\n        if route not in self.time: self.time[route] = [0,0]\n        self.time[route][0] += t - time\n        self.time[route][1] += 1\n\n\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\n        total, count = self.time[(startStation, endStation)]\n        return total / count",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Hash Map"
  },
  {
    "title": "Find All Good Strings",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        a = ord('a')\n        z = ord('z')\n        \n        arr_e = list(map(ord, evil))\n        len_e = len(evil)\n        next = [0] * len_e\n\n        for i in range(1, len_e):\n            j = next[i - 1]\n            while j > 0 and evil[i] != evil[j]:\n                j = next[j - 1]\n            if evil[i] == evil[j]:\n                next[i] = j + 1\n\n        def good(s):\n            arr = list(map(ord, s))\n            len_a = len(arr)\n\n            @cache\n            def f(i, skip, reach, e):\n                if e == len_e:\n                    return 0\n                if i == len_a:\n                    return 0 if skip else 1\n\n                limit = arr[i] if reach else z\n                ans = 0\n\n                if skip:\n                    ans += f(i + 1, True, False, 0)\n\n                for c in range(a, limit + 1):\n                    ee = e\n                    while ee > 0 and arr_e[ee] != c:\n                        ee = next[ee - 1] \n\n                    if arr_e[ee] == c:\n                        ee += 1\n\n                    ans += f(i + 1, False, reach and c == limit, ee)\n\n                return ans % int(1e9 + 7)\n\n            return f(0, True, True, 0)\n\n        return (good(s2) - good(s1) + int(evil not in s1)) % int(1e9 + 7)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "The main algorithmic approach used here is \"Dynamic Programming\" with memoization using the `@cache` decorator."
  },
  {
    "title": "Maximum Points You Can Obtain From Cards",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints)\n\n        score = maxScore = sum(cardPoints[:k])\n\n        for i in range(1, k + 1):\n            score += cardPoints[-i] - cardPoints[k - i]\n            maxScore = max(maxScore, score)\n\n        return maxScore",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "dynamic programming"
    ],
    "approach": "Greedy"
  },
  {
    "title": "Count Good Nodes In Binary Tree",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        def dfs(node, maxVal):\n            if not node:\n                return 0\n\n            res = 1 if node.val >= maxVal else 0\n            maxVal = max(maxVal, node.val)\n            res += dfs(node.left, maxVal)\n            res += dfs(node.right, maxVal)\n            return res\n\n        return dfs(root, root.val)",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "recursion",
      "tree"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Maximum Number Of Vowels In A Substring Of Given Length",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        l, res, total = 0, 0, 0\n        vowels = \"aeiou\"\n\n        for r in range(len(s)):\n            if s[r] in vowels:\n                total += 1\n            if (r - l + 1) > k:\n                if s[l] in vowels:\n                    total -= 1\n                l += 1\n            res = max(res, total)\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "array"
    ],
    "approach": "Two Pointers."
  },
  {
    "title": "Check If A String Contains All Binary Codes Of Size K",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def hasAllCodes(self, s: str, k: int) -> bool:\n        return len(set(s[i : i + k] for i in range(len(s) - k + 1))) == 2**k",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "hash table"
    ],
    "approach": "\"Hash Map\""
  },
  {
    "title": "Course Schedule Iv",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n        adj = defaultdict(list)\n        for prereq, crs in prerequisites:\n            adj[crs].append(prereq)\n        \n        def dfs(crs):\n            if crs not in prereqMap:\n                prereqMap[crs] = set()\n                for pre in adj[crs]:\n                    prereqMap[crs] |= dfs(pre)\n            prereqMap[crs].add(crs)\n            return prereqMap[crs]\n\n        prereqMap = {} # map course -> set indirect prereqs\n        for crs in range(numCourses):\n            dfs(crs)\n\n        res = []\n        for u, v in queries:\n            res.append(u in prereqMap[v])\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "hash table",
      "recursion"
    ],
    "approach": "Dynamic Programming (specifically DFS-based DP)"
  },
  {
    "title": "Maximum Product Of Two Elements In An Array",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        high = secondHigh = 0\n        for n in nums:\n            if n > high:\n                secondHigh = high\n                high = n\n            else:\n                secondHigh = max(n, secondHigh)\n        return (high - 1) * (secondHigh - 1)",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Sorting."
  },
  {
    "title": "Reorder Routes To Make All Paths Lead To The City Zero",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def minReorder(self, n: int, connections: List[List[int]]) -> int:\n        edges = {(a,b) for a, b in connections}\n        neighbors = defaultdict(list)\n        visit = set()\n        changes = 0\n\n        for a, b in connections:\n            neighbors[a].append(b)\n            neighbors[b].append(a)\n        \n        def dfs(city):\n            nonlocal changes\n\n            for neighbor in neighbors[city]:\n                if neighbor in visit:\n                    continue\n                if (neighbor, city) not in edges:\n                    changes += 1\n                visit.add(neighbor)\n                dfs(neighbor)\n        visit.add(0)\n        dfs(0)\n        return changes",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "hash table",
      "recursion"
    ],
    "approach": "DFS (Depth-First Search)"
  },
  {
    "title": "Design Browser History",
    "description": "No description available.",
    "optimal_code": "class ListNode:\n    def __init__(self, val, prev=None, next=None):\n        self.val = val\n        self.prev = prev\n        self.next = next\n\nclass BrowserHistory:\n    def __init__(self, homepage: str):\n        self.cur = ListNode(homepage)\n\n    def visit(self, url: str) -> None:\n        self.cur.next = ListNode(url, self.cur)\n        self.cur = self.cur.next\n\n    def back(self, steps: int) -> str:\n        while self.cur.prev and steps > 0:\n            self.cur = self.cur.prev\n            steps -= 1\n        return self.cur.val\n\n    def forward(self, steps: int) -> str:\n        while self.cur.next and steps > 0:\n            self.cur = self.cur.next\n            steps -= 1\n        return self.cur.val\n\n\nclass BrowserHistory:    \n    def __init__(self, homepage: str):\n        self.i = 0\n        self.len = 1\n        self.history = [homepage]\n\n    def visit(self, url: str) -> None:\n        if len(self.history) < self.i + 2:\n            self.history.append(url)\n        else:\n            self.history[self.i + 1] = url\n        self.i += 1\n        self.len = self.i + 1\n\n    def back(self, steps: int) -> str:\n        self.i = max(self.i - steps, 0)\n        return self.history[self.i]\n\n    def forward(self, steps: int) -> str:\n        self.i = min(self.i + steps, self.len - 1)\n        return self.history[self.i]",
    "time_complexity": "O(log n)",
    "space_complexity": "O(1)",
    "tags": [
      "binary search",
      "linked list"
    ],
    "approach": "The main algorithmic approach used is \"Single Pointer\" (also known as \"One Pointer\"). This is because in both the provided solutions, a pointer or index (`self.cur` and `self.i`) is updated to navigate through the history of URLs. The pointer moves forward or backward based on the operations performed."
  },
  {
    "title": "Final Prices With A Special Discount In A Shop",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def finalPrices(self, prices: List[int]) -> List[int]:\n        stack = []\n        res = []\n        for i in range(len(prices) - 1, -1, -1):\n            if len(stack) == 0:\n                res.append(prices[i])\n            elif len(stack) and stack[-1] <= prices[i]:\n                res.append(prices[i] - stack[-1])\n            elif len(stack) and stack[-1] > prices[i]:\n                while len(stack) and stack[-1] > prices[i]:\n                    stack.pop()\n                if len(stack) == 0:\n                    res.append(prices[i])\n                else: \n                    res.append(prices[i] - stack[-1])\n            stack.append(prices[i])\n        res.reverse()\n        return res",
    "time_complexity": "O(log n)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "binary search"
    ],
    "approach": "\"Stack\""
  },
  {
    "title": "Least Number Of Unique Integers After K Removals",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int: \n        freq = Counter(arr)\n        heap = list(freq.values())\n        heapq.heapify(heap)\n\n        res = len(heap)\n        while k > 0 and heap:\n            f = heapq.heappop(heap)\n            if k >= f:\n                k -= f\n                res -= 1\n        return res\n\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int: \n        freq = Counter(arr)\n        freqList = [0] * (len(arr) + 1)\n\n        for n, f in freq.items():\n            freqList[f] += 1\n\n        res = len(freq)\n        for f in range(1, len(freqList)):\n            remove = freqList[f]\n            if k >= f * remove:\n                k -= f * remove\n                res -= remove\n            else:\n                remove = k // f\n                res -= remove\n                break\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "math"
    ],
    "approach": "The main algorithmic approach used is \"Greedy\"."
  },
  {
    "title": "Find Critical And Pseudo Critical Edges In Minimum Spanning Tree",
    "description": "No description available.",
    "optimal_code": "class UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.rank = [1] * n\n\n    def find(self, v1):\n        while v1 != self.par[v1]:\n            self.par[v1] = self.par[self.par[v1]]\n            v1 = self.par[v1]\n        return v1\n\n    def union(self, v1, v2):\n        p1, p2 = self.find(v1), self.find(v2)\n        if p1 == p2:\n            return False\n        if self.rank[p1] > self.rank[p2]:\n            self.par[p2] = p1\n            self.rank[p1] += self.rank[p2]\n        else:\n            self.par[p1] = p2\n            self.rank[p2] += self.rank[p1]\n        return True\n\nclass Solution:\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        for i, e in enumerate(edges):\n            e.append(i) # [v1, v2, weight, original_index]\n\n        edges.sort(key=lambda e: e[2])\n\n        mst_weight = 0\n        uf = UnionFind(n)\n        for v1, v2, w, i in edges:\n            if uf.union(v1, v2):\n                mst_weight += w\n\n        critical, pseudo = [], []\n        for n1, n2, e_weight, i in edges:\n            weight = 0\n            uf = UnionFind(n)\n            for v1, v2, w, j in edges:\n                if i != j and uf.union(v1, v2):\n                    weight += w\n            if max(uf.rank) != n or weight > mst_weight:\n                critical.append(i)\n                continue\n            \n            uf = UnionFind(n)\n            uf.union(n1, n2)\n            weight = e_weight\n            for v1, v2, w, j in edges:\n                if uf.union(v1, v2):\n                    weight += w\n            if weight == mst_weight:\n                pseudo.append(i)\n        return [critical, pseudo]",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "dynamic programming"
    ],
    "approach": "The main algorithmic approach used is \"Union-Find\" or more specifically \"Disjoint Set Union\"."
  },
  {
    "title": "Number Of Subsequences That Satisfy The Given Sum Condition",
    "description": "No description available.",
    "optimal_code": "\nclass Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n\n        res, mod = 0, (10**9 + 7)\n\n        left, right = 0, len(nums) - 1\n        while  left <= right:\n            if (nums[left] + nums[right]) > target:\n                right -= 1\n            else:\n                res += 1 << (right - left)\n                left += 1\n        return res % mod",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "\"Two Pointers\""
  },
  {
    "title": "Path With Maximum Probability",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        adj = collections.defaultdict(list)\n        for i in range(len(edges)):\n            src, dst = edges[i]\n            adj[src].append([dst, succProb[i]])\n            adj[dst].append([src, succProb[i]])\n\n        pq = [(-1, start)]\n        visit = set()\n\n        while pq:\n            prob, cur = heapq.heappop(pq)\n            visit.add(cur)\n\n            if cur == end:\n                return prob * -1\n            for nei, edgeProb in adj[cur]:\n                if nei not in visit:\n                    heapq.heappush(pq, (prob * edgeProb, nei))\n        return 0",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "hash table"
    ],
    "approach": "The main algorithmic approach used is \"Priority Queue\" or more specifically \"Dijkstra's Algorithm\"."
  },
  {
    "title": "Count Odd Numbers In An Interval Range",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def countOdds(self, low: int, high: int) -> int:\n        if low%2!=0 or high%2!=0:\n            return (high-low)//2 +1\n        return (high-low)//2",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "Greedy"
  },
  {
    "title": "Matrix Diagonal Sum",
    "description": "No description available.",
    "optimal_code": "\nclass Solution:\n    def PrimeSum(self,mat):\n        cnt = 0\n        for i in range(len(mat)):\n            cnt += mat[i][i]\n        return cnt\n\n    def CrossSum(self,mat):\n        cnt = 0\n        for i in range(len(mat)):\n            cnt += mat[i][len(mat) - i - 1]\n        return cnt\n\n    def diagonalSum(self, mat: List[List[int]]) -> int:\n        prime = self.PrimeSum(mat)\n        cross = self.CrossSum(mat)\n\n        if len(mat) % 2 == 0:\n            return prime + cross\n        else:\n            mid = len(mat) // 2\n            mid_ele = mat[mid][mid]\n            return prime + cross - mid_ele",
    "time_complexity": "O(log n)",
    "space_complexity": "O(1)",
    "tags": [
      "array",
      "binary search",
      "math"
    ],
    "approach": "The main algorithmic approach used is: \"Dynamic Programming\""
  },
  {
    "title": "Special Positions In A Binary Matrix",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def numSpecial(self, mat: List[List[int]]) -> int:\n        m = len(mat)\n        n = len(mat[0])\n        rowCount = [0] * m\n        colCount = [0] * n\n        res = 0\n        for r in range(m):\n            for c in range(n):\n                if mat[r][c] == 1:\n                    rowCount[r] += 1\n                    colCount[c] += 1\n        for r in range(m):\n            for c in range(n):\n                if mat[r][c] == 1 and rowCount[r] == 1 and colCount[c] == 1:\n                    res += 1\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "Two Pointers"
  },
  {
    "title": "Min Cost To Connect All Points",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        adj = {i: [] for i in range(N)}  # i : list of [cost, node]\n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i + 1, N):\n                x2, y2 = points[j]\n                dist = abs(x1 - x2) + abs(y1 - y2)\n                adj[i].append([dist, j])\n                adj[j].append([dist, i])\n\n        res = 0\n        visit = set()\n        minH = [[0, 0]]  # [cost, point]\n        while len(visit) < N:\n            cost, i = heapq.heappop(minH)\n            if i in visit:\n                continue\n            res += cost\n            visit.add(i)\n            for neiCost, nei in adj[i]:\n                if nei not in visit:\n                    heapq.heappush(minH, [neiCost, nei])\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Design Parking System",
    "description": "No description available.",
    "optimal_code": "class ParkingSystem:\n\n    def __init__(self, big: int, medium: int, small: int):\n        \n        self.parking = {\n            1: [0 ,big],\n            2: [0, medium],\n            3: [0, small]\n        }\n\n    def addCar(self, carType: int) -> bool:\n        new_total = self.parking[carType][0] + 1\n        if new_total <= self.parking[carType][1]:\n            self.parking[carType][0] += 1\n            return True\n        return False",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Hash Map\" or \"Dictionary\". The problem involves using a dictionary to store and retrieve data efficiently."
  },
  {
    "title": "Even Odd Tree",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def isEvenOddTree(self, root: Optional[TreeNode]) -> bool:\n        even = True\n        q = deque([root])\n\n        while q:\n            prev = float(\"-inf\") if even else float(\"inf\")\n            for _ in range(len(q)):\n                node = q.popleft()\n\n                if even and (node.val % 2 == 0 or node.val <= prev):\n                    return False\n                elif not even and (node.val % 2 == 1 or node.val >= prev):\n                    return False\n                \n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n                prev = node.val\n            even = not even\n        return True",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "array",
      "math",
      "tree"
    ],
    "approach": "\"BFS\" (Breadth-First Search)"
  },
  {
    "title": "Path With Minimum Effort",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def minimumEffortPath(self, heights: List[List[int]]) -> int:\n        m, n = len(heights), len(heights[0])\n        \n        efforts = [[float('inf')] * n for _ in range(m)]\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        efforts[0][0] = 0\n        pq = [(0, 0, 0)]  # (effort, row, col)\n        \n        while pq:\n            curEffort, i, j = heapq.heappop(pq)\n            \n            if i == m - 1 and j == n - 1:\n                return curEffort\n            \n            for dx, dy in directions:\n                x, y = i + dx, j + dy\n                \n                if 0 <= x < m and 0 <= y < n:\n                    newEffort = max(abs(heights[x][y] - heights[i][j]), curEffort)\n                    \n                    if newEffort < efforts[x][y]:\n                        efforts[x][y] = newEffort\n                        heapq.heappush(pq, (newEffort, x, y))\n        \n        return efforts[m - 1][n - 1]",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "dynamic programming"
    ],
    "approach": "Priority Queue (with Priority Queue algorithmic term)"
  },
  {
    "title": "Furthest Building You Can Reach",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:\n        heap = []\n\n        for i in range(len(heights) - 1):\n            diff = heights[i + 1] - heights[i]\n            if diff <= 0:\n                continue\n\n            bricks -= diff\n            heapq.heappush(heap, -diff)\n\n            if bricks < 0:\n                if ladders == 0:\n                    return i\n                ladders -= 1\n                bricks += -heapq.heappop(heap)\n            \n        return len(heights) - 1",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "array"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Minimum Operations To Reduce X To Zero",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        target_sum = sum(nums) - x\n        if target_sum < 0:\n            return -1\n\n        n = len(nums)\n        min_ops = -1\n\n        left = 0\n        right = 0\n        curr_sum = 0\n        while right < n:\n            curr_sum += nums[right] \n            right += 1\n\n            while left < n and curr_sum > target_sum:\n                curr_sum -= nums[left]\n                left += 1\n\n            if curr_sum == target_sum:\n                ops = n - (right - left) # determine no. of operations used in reduction of nums to candidate subarray \n                min_ops = ops if min_ops == -1 else min(min_ops, ops) # determine if candidate is best candidate thus far\n\n        return min_ops # return best candidate",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Two Pointers"
  },
  {
    "title": "Merge In Between Linked Lists",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\n        curr = list1\n        i = 0\n        while i < a - 1:\n            curr = curr.next\n            i += 1\n\n        head = curr\n        while i <= b:\n            curr = curr.next\n            i += 1\n        head.next = list2\n\n        while list2.next:\n            list2 = list2.next\n        list2.next = curr\n        return list1",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "linked list"
    ],
    "approach": "\"Two Pointers\""
  },
  {
    "title": "Number Of Students Unable To Eat Lunch",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def countStudents(self, students: List[int], sandwiches: List[int]) -> int:\n        num_of_students_back_in_line = 0\n        while num_of_students_back_in_line != len(students):\n            curr_student = students.pop(0)\n            if curr_student == sandwiches[0]:\n                sandwiches.pop(0)\n                num_of_students_back_in_line = 0\n            else:\n                students.append(curr_student)\n                num_of_students_back_in_line += 1\n        return len(students)",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Two Pointers\"."
  },
  {
    "title": "Swapping Nodes In A Linked List",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        right_pointer = head\n        for _ in range(1, k):\n            right_pointer = right_pointer.next\n        left_kth_node = right_pointer\n\n        left_pointer = head\n        while right_pointer is not None:\n            right_kth_node = left_pointer\n            right_pointer = right_pointer.next\n            left_pointer = left_pointer.next\n\n        left_kth_node.val, right_kth_node.val = right_kth_node.val, left_kth_node.val\n        return head",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "linked list"
    ],
    "approach": "Two Pointers"
  },
  {
    "title": "Minimum Length Of String After Deleting Similar Ends",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def minimumLength(self, s: str) -> int:\n        l, r = 0, len(s) - 1\n\n        while l < r and s[l] == s[r]:\n            tmp = s[l]\n            while l <= r and s[l] == tmp:\n                l += 1\n            while l <= r and s[r] == tmp:\n                r -= 1\n        return (r - l + 1)",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "sliding window",
      "two pointers"
    ],
    "approach": "Two Pointers"
  },
  {
    "title": "Merge Strings Alternately",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def mergeAlternately(self, word1: str, word2: str) -> str:\n        i = j = 0\n        res = []\n\n        while i < len(word1) and j < len(word2):\n            res.append(word1[i])\n            res.append(word2[j])\n            i += 1\n            j += 1\n        res.append(word1[i:])\n        res.append(word2[j:])\n        return ''.join(res)",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "\"Two Pointers\""
  },
  {
    "title": "Maximum Ascending Subarray Sum",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int:\n        curSum = results = nums[0]\n\n        for i in range(1, len(nums)):\n            if nums[i] <= nums[i - 1]:\n                curSum = 0\n            curSum += nums[i]\n            results = max(curSum, results)\n\n        return results",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Greedy"
  },
  {
    "title": "Sign Of The Product Of An Array",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def arraySign(self, nums: List[int]) -> int:\n        flag = True\n        for i in nums:\n            if i == 0:\n                return 0\n            if i < 0:\n                flag = not flag\n        \n        return 1 if flag else -1",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Greedy"
  },
  {
    "title": "Single Threaded Cpu",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        tasks = sorted([(t[0], t[1], i) for i, t in enumerate(tasks)])\n        result, heap = [], []\n        cur_task_index = 0\n        cur_time = tasks[0][0]\n        \n        while len(result) < len(tasks):\n            while (cur_task_index < len(tasks)) and (tasks[cur_task_index][0] <= cur_time):\n                heapq.heappush(heap, (tasks[cur_task_index][1], tasks[cur_task_index][2]))\n                cur_task_index += 1\n            if heap:\n                time_difference, original_index = heapq.heappop(heap)\n                cur_time += time_difference\n                result.append(original_index)\n            elif cur_task_index < len(tasks):\n                cur_time = tasks[cur_task_index][0]\n                \n        return result",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Dynamic Programming."
  },
  {
    "title": "Frequency Of The Most Frequent Element",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxFrequency(self, nums: List[int], k: int) -> int:\n        nums.sort()\n\n        l, r = 0, 0\n        res, total = 0, 0\n\n        while r < len(nums):\n            total += nums[r]\n            while nums[r] * (r - l + 1) > total + k:\n                total -= nums[l]\n                l += 1\n            res = max(res, r - l + 1)\n            r += 1\n        \n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "Two Pointers"
  },
  {
    "title": "Seat Reservation Manager",
    "description": "No description available.",
    "optimal_code": "import heapq\n\nclass SeatManager:\n\n    def __init__(self, n: int):\n        self.seats = [i for i in range(1, n + 1)]\n\n    def reserve(self) -> int:\n        return heapq.heappop(self.seats)\n\n    def unreserve(self, seatNumber: int) -> None:\n        heapq.heappush(self.seats, seatNumber)",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Heap/Priority Queue."
  },
  {
    "title": "Splitting A String Into Descending Consecutive Values",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def splitString(self, s: str) -> bool:\n        \n        def dfs(index, prev):\n            if index == len(s):\n                return True\n        \n            for j in range(index, len(s)):\n                val = int(s[index:j+1])\n                if val + 1 == prev and dfs(j+1, val):\n                    return True\n            return False\n    \n        for i in range(len(s) - 1):\n            val = int(s[:i + 1])\n            if dfs(i+1, val): return True\n                \n        return False",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "array",
      "dfs",
      "recursion"
    ],
    "approach": "DFS (Depth-First Search)"
  },
  {
    "title": "Minimum Interval To Include Each Query",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\n        intervals.sort()\n        minHeap = []\n        res = {}\n        i = 0\n        for q in sorted(queries):\n            while i < len(intervals) and intervals[i][0] <= q:\n                l, r = intervals[i]\n                heapq.heappush(minHeap, (r - l + 1, r))\n                i += 1\n\n            while minHeap and minHeap[0][1] < q:\n                heapq.heappop(minHeap)\n            res[q] = minHeap[0][0] if minHeap else -1\n        return [res[q] for q in queries]",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "The main algorithmic approach used is \"Two Pointers\"."
  },
  {
    "title": "Minimum Number Of Flips To Make The Binary String Alternating",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def minFlips(self, s: str) -> int:\n        n = len(s)\n        s = s + s\n        alt1, alt2 = \"\", \"\"\n\n        for i in range(len(s)):\n            alt1 += \"0\" if i % 2 == 0 else \"1\"\n            alt2 += \"1\" if i % 2 == 0 else \"0\"\n\n        res = float('inf')\n        diff1, diff2 = 0, 0\n        l = 0\n        for r in range(len(s)):\n            if s[r] != alt1[r]:\n                diff1 += 1\n            if s[r] != alt2[r]:\n                diff2 += 1\n            if (r - l + 1) > n:\n                if s[l] != alt1[l]:\n                    diff1 -= 1\n                if s[l] != alt2[l]:\n                    diff2 -= 1\n                l += 1\n            if (r - l + 1) == n:\n                res = min(res, diff1, diff2)\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "array",
      "math"
    ],
    "approach": "Sliding Window"
  },
  {
    "title": "Merge Triplets To Form Target Triplet",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:\n        good = set()\n\n        for t in triplets:\n            if t[0] > target[0] or t[1] > target[1] or t[2] > target[2]:\n                continue\n            for i, v in enumerate(t):\n                if v == target[i]:\n                    good.add(i)\n        return len(good) == 3",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Sorting"
  },
  {
    "title": "Count Sub Islands",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\n        ROWS, COLS = len(grid1), len(grid1[0])\n        visit = set()\n\n        def dfs(r, c):\n            if (\n                r < 0\n                or c < 0\n                or r == ROWS\n                or c == COLS\n                or grid2[r][c] == 0\n                or (r, c) in visit\n            ):\n                return True\n\n            visit.add((r, c))\n            res = True\n            if grid1[r][c] == 0:\n                res = False\n\n            res = dfs(r - 1, c) and res\n            res = dfs(r + 1, c) and res\n            res = dfs(r, c - 1) and res\n            res = dfs(r, c + 1) and res\n            return res\n\n        count = 0\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid2[r][c] and (r, c) not in visit and dfs(r, c):\n                    count += 1\n        return count",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "hash table",
      "recursion"
    ],
    "approach": "\"Depth-First Search\" or \"DFS\""
  },
  {
    "title": "Concatenation Of Array",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def getConcatenation(self, nums: List[int]) -> List[int]:\n        ans = []\n        for i in range(2):\n            for n in nums:\n                ans.append(n)\n        return ans",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "\"Looping/Iteration\""
  },
  {
    "title": "Unique Length 3 Palindromic Subsequences",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def countPalindromicSubsequence(self, s: str) -> int:\n        count = 0\n        chars = set(s)\n        for char in chars:\n            first,last = s.find(char),s.rfind(char)\n            count += len(set(s[first+1:last]))\n        return count",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "Sliding Window"
  },
  {
    "title": "Check If Move Is Legal",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def checkMove(self, board: List[List[str]], rMove: int, cMove: int, color: str) -> bool:\n        ROWS, COLS = len(board), len(board[0])\n        direction = [[1, 0], [-1, 0], [0, 1], [0, -1],\n                     [1, 1], [-1, -1], [1, -1], [-1, 1]]\n        board[rMove][cMove] = color\n        \n        def legal(row, col, color, direc):\n            dr, dc = direc\n            row, col = row + dr, col + dc\n            length = 1\n            \n            while(0 <= row < ROWS and 0 <= col < COLS):\n                length += 1\n                if board[row][col] == '.': return False\n                if board[row][col] == color:\n                    return length >= 3\n                row, col = row + dr, col + dc\n            return False\n        \n        for d in direction:\n            if legal(rMove, cMove, color, d): return True\n        return False",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"DFS\" (Depth-First Search)."
  },
  {
    "title": "Minimum Number Of Swaps To Make The String Balanced",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def minSwaps(self, s: str) -> int:\n        extraClose, maxClose = 0, 0\n\n        for c in s:\n            if c == \"[\":\n                extraClose -= 1\n            else:\n                extraClose += 1\n\n            maxClose = max(maxClose, extraClose)\n\n        return (maxClose + 1) // 2  # Or math.ceil(maxClose / 2)",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "\"Greedy\""
  },
  {
    "title": "Array With Elements Not Equal To Average Of Neighbors",
    "description": "No description available.",
    "optimal_code": "class Solution:\n\n\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\n        nums.sort()\n\n        i, j, n = 0, 0, len(nums)\n        ans = [0]*n\n\n        while i < n and j < n:\n            ans[i] = nums[j]\n            i = i + 2\n            j = j + 1\n\n        i = 1\n        while i < n and j < n:\n            ans[i] = nums[j]\n            i = i + 2\n            j = j + 1\n\n        return ans",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "\"Sorting\""
  },
  {
    "title": "Find Unique Binary String",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findDifferentBinaryString(self, nums: List[str]) -> str:\n        \n        strSet = { s for s in nums }\n        \n        def backtrack(i, cur):\n            if i == len(nums):\n                res = \"\".join(cur)\n                return None if res in strSet else res\n            \n            res = backtrack(i+1, cur)\n            if res: return res\n            \n            cur[i] = \"1\"\n            res = backtrack(i+1, cur)\n            if res: return res\n            \n        return backtrack(0, [\"0\" for s in nums])",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "The main algorithmic approach used is \"Backtracking\"."
  },
  {
    "title": "Minimum Difference Between Highest And Lowest Of K Scores",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        l, r = 0, k - 1\n        res = float(\"inf\")\n        \n        while r < len(nums):\n            res = min(res, nums[r] - nums[l])\n            l, r = l + 1, r + 1\n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "\"Two Pointers\""
  },
  {
    "title": "Find The Kth Largest Integer In The Array",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def kthLargestNumber(self, nums: List[str], k: int) -> str:\n        maxHeap = [-int(n) for n in nums]\n        heapq.heapify(maxHeap)\n        while k>1:\n            heapq.heappop(maxHeap)\n            k-=1\n        return str(-maxHeap[0])",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "\"Priority Queue\" (specifically, a max heap implemented with `heapq` in Python)"
  },
  {
    "title": "Number Of Pairs Of Interchangeable Rectangles",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:\n        count = {}  # { W / H : Count }\n        res = 0\n\n        for w, h in rectangles:\n            count[w / h] = 1 + count.get(w / h, 0)\n\n        for c in count.values():\n            res += (c * (c - 1)) // 2\n\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table",
      "math"
    ],
    "approach": "Hash Map"
  },
  {
    "title": "Maximum Product Of The Length Of Two Palindromic Subsequences",
    "description": "No description available.",
    "optimal_code": "\"\"\"\nTime Complexity: O(2^N)\nSpace Complexity: O(2^N)\n\"\"\"\nclass Solution:\n    def maxProduct(self, s):\n        n = len(s)\n        \n        first, last = [0]*(1<<n), [0]*(1<<n)\n        \n        for i in range(n):\n            for j in range(1<<i, 1<<(i+1)):\n                first[j] = i\n\n        for i in range(n):\n            for j in range(1<<i, 1<<n, 1<<(i+1)):\n                last[j] = i\n        \n        @lru_cache(None)\n        def dp(m):\n            if m & (m-1) == 0: return m != 0\n            l, f = last[m], first[m]\n            lb, fb = 1<<l, 1<<f\n            return max(dp(m-lb), dp(m-fb), dp(m-lb-fb) + (s[l] == s[f]) * 2)\n       \n        ans = 0\n        for m in range(1, 1<<n):\n            ans = max(ans, dp(m)*dp((1<<n) - 1 - m))\n            \n        return ans",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "dynamic programming"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Detect Squares",
    "description": "No description available.",
    "optimal_code": "class DetectSquares:\n    def __init__(self):\n        self.ptsCount = defaultdict(int)\n        self.pts = []\n\n    def add(self, point: List[int]) -> None:\n        self.ptsCount[tuple(point)] += 1\n        self.pts.append(point)\n\n    def count(self, point: List[int]) -> int:\n        res = 0\n        px, py = point\n        for x, y in self.pts:\n            if (abs(py - y) != abs(px - x)) or x == px or y == py:\n                continue\n            res += self.ptsCount[(x, py)] * self.ptsCount[(px, y)]\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "\"Hash Map\""
  },
  {
    "title": "Grid Game",
    "description": "No description available.",
    "optimal_code": "\nclass Solution(object):\n    def gridGame(self, grid):\n        result = float(\"inf\")\n        left, right = 0, sum(grid[0])\n\n        for a, b in zip(grid[0], grid[1]):\n            right -= a\n            result = min(result, max(left, right))\n            left += b\n        return result",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Two Pointers\"."
  },
  {
    "title": "Find All People With Secret",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n        secrets = set([0, firstPerson])\n        time_map = {}\n\n        for src, dst, t in meetings:\n            if t not in time_map:\n                time_map[t] = defaultdict(list)\n            time_map[t][src].append(dst)\n            time_map[t][dst].append(src)\n        \n        def dfs(src, adj):\n            if src in visit:\n                return\n            visit.add(src)\n            secrets.add(src)\n            for nei in adj[src]:\n                dfs(nei, adj)\n\n        for t in sorted(time_map.keys()):\n            visit = set()\n            for src in time_map[t]:\n                if src in secrets:\n                    dfs(src, time_map[t])\n        return list(secrets)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "dfs",
      "hash table",
      "recursion"
    ],
    "approach": "Dynamic Programming and DFS"
  },
  {
    "title": "Detonate The Maximum Bombs",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\n        n = len(bombs)\n        graph = [[] for _ in range(n)]\n\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    x1, y1, r1 = bombs[i]\n                    x2, y2, _ = bombs[j]\n\n                    dst = sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\n                    if dst <= r1:\n                        graph[i].append(j)\n\n        def dfs(node, vis):\n            vis[node] = True\n            count = 1\n\n            for nbh in graph[node]:\n                if not vis[nbh]:\n                    count += dfs(nbh, vis)\n                    \n            return count\n\n        detonated = 0\n\n        for i in range(n):\n            visited = [False] * n\n            detonated = max(detonated, dfs(i, visited))\n        \n        return detonated",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "dfs",
      "recursion"
    ],
    "approach": "DFS (Depth-First Search)"
  },
  {
    "title": "Maximum Twin Sum Of A Linked List",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def pairSum(self, head: Optional[ListNode]) -> int:\n        slow, fast = head, head\n        prev = None\n        while fast and fast.next:\n            fast = fast.next.next\n            tmp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = tmp\n\n        res = 0\n        while slow:\n            res = max(res, prev.val + slow.val)\n            prev = prev.next\n            slow = slow.next\n        return res",
    "time_complexity": "Unknown",
    "space_complexity": "O(n)",
    "tags": [
      "linked list"
    ],
    "approach": "The main algorithmic approach used here is \"Two Pointers\"."
  },
  {
    "title": "Find The Difference Of Two Arrays",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\n        nums1 = set(nums1)\n        nums2 = set(nums2)\n        table = {}\n        for _, val in enumerate(nums2):\n            table[val] = 1\n\n        unik1 = []\n        unik2 = []\n        for i in nums1:\n            if i in table:\n                table[i] += 1\n            else:\n                unik1.append(i)\n        \n        for key, val in table.items():\n            if val == 1:\n                unik2.append(key)\n        return [unik1, unik2]\n\n      \n\nfrom typing import List  # ignore this, just for typing\n\n\nclass Solution:\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\n        nums1_set = set(nums1)\n        nums2_set = set(nums2)\n\n        lst1 = [num for num in nums1_set if num not in nums2_set]\n        lst2 = [num for num in nums2_set if num not in nums1_set]\n\n        return [lst1, lst2]",
    "time_complexity": "O(m + n), we check each element of nums1Set and nums2Set",
    "space_complexity": "O(m + n), where m and n are length sets in worst case.",
    "tags": [
      "hash table"
    ],
    "approach": "The main algorithmic approach used is \"Set Operations\"."
  },
  {
    "title": "Add Two Integers",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def sum(self, num1: int, num2: int) -> int:\n        return num1 + num2",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "\"Simple Arithmetic\""
  },
  {
    "title": "Successful Pairs Of Spells And Potions",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\n        pairs = []\n        potions.sort()\n        n = len(potions)\n\n        for i in range(len(spells)):\n            l, r = 0, len(potions) - 1\n            \n            while l <= r:\n                m = (l + r) // 2\n                if spells[i] * potions[m] >= success:\n                    r = m - 1\n                else:\n                    l = m + 1\n            if l < len(potions):\n                pairs.append(n - l)\n            else:\n                pairs.append(0)\n\n        return pairs",
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "tags": [
      "array",
      "math"
    ],
    "approach": "Binary Search"
  },
  {
    "title": "Naming A Company",
    "description": "No description available.",
    "optimal_code": "class Solution(object):\n\n    def distinctNames(self, ideas):\n\n        suffixes = dict()\n        for idea in ideas:\n            if idea[0] not in suffixes:\n                suffixes[idea[0]] = set()\n            suffixes[idea[0]].add(idea[1:])\n\n        if len(suffixes) < 2:\n            return 0\n\n        num_distinct_names = 0\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        for prefix_1 in suffixes:\n            for prefix_2 in suffixes:\n                if prefix_2 > prefix_1:\n                    num_suffixes_1 = len(suffixes[prefix_1])\n                    num_suffixes_2 = len(suffixes[prefix_2])\n                    for suffix in suffixes[prefix_1]:\n                        if suffix in suffixes[prefix_2]:\n                            num_suffixes_1 -= 1\n                            num_suffixes_2 -= 1\n                    num_distinct_names += 2 * num_suffixes_1 * num_suffixes_2\n\n        return num_distinct_names",
    "time_complexity": "O(log n)",
    "space_complexity": "O(n)",
    "tags": [
      "binary search",
      "hash table"
    ],
    "approach": "The main algorithmic approach used is \"Two Pointers\"."
  },
  {
    "title": "Number Of Zero Filled Subarrays",
    "description": "No description available.",
    "optimal_code": "class Solution(object):\n    def zeroFilledSubarray(self, nums):\n        res = nums.count(0)\n        if res == 0:\n            return 0\n             \n        r = 0\n        l = len(nums)\n        while r < l:\n            Temp_Subarray=[]\n            while r < l and nums[r] == 0:\n                Temp_Subarray.append(nums[r])\n                r += 1\n            if len(Temp_Subarray) > 1:\n                Temp_Count =  len(Temp_Subarray) * ( len(Temp_Subarray) - 1 ) / 2 \n                res += int(Temp_Count)\n\n            r += 1\n        return res",
    "time_complexity": "O(log n)",
    "space_complexity": "O(n)",
    "tags": [
      "binary search"
    ],
    "approach": "Two Pointers"
  },
  {
    "title": "Removing Stars From A String",
    "description": "No description available.",
    "optimal_code": "class Solution(object) :\n    def removeStars(self, s) :\n        res = []\n        for c in s :\n            if res and c == '*':\n                res.pop()\n            else:\n                res.append(c)\n        return ''.join(res)",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Two Pointers\"."
  },
  {
    "title": "Meeting Rooms Iii",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\n        meetings.sort()\n\n        available = [i for i in range(n)]\n        used = []\n        count = [0] * n\n\n        for start, end in meetings:\n            while used and start >= used[0][0]:\n                _, room = heapq.heappop(used)\n                heapq.heappush(available, room)\n\n            if not available:\n                end_time, room = heapq.heappop(used)\n                end = end_time + (end - start)\n                heapq.heappush(available, room)\n\n            room = heapq.heappop(available)\n            heapq.heappush(used, (end, room))\n            count[room] += 1\n\n        return count.index(max(count))",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Priority Queue\" or more specifically \"Heap\"."
  },
  {
    "title": "Optimal Partition Of String",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def partitionString(self, s: str) -> int:\n        c=0\n        res=set()\n        for i in s:\n            if i in res:\n                c=c+1\n                res=set()\n            res.add(i)\n        return c+1",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table"
    ],
    "approach": "\"Hash Set\" or simply \"HashSet\"."
  },
  {
    "title": "Difference Between Ones And Zeros In Row And Column",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:\n        m , n = len(grid), len(grid[0])\n        rowCount = [[0, 0] for _ in range(m)] # (zeros, ones)\n        colCount = [[0, 0] for _ in range(n)]\n        res = []\n        for r in range(m):\n            for c in range(n):\n                if grid[r][c] == 1:\n                    rowCount[r][1] += 1\n                    colCount[c][1] += 1\n                else:\n                    rowCount[r][0] += 1\n                    colCount[c][0] += 1\n        for r in range(m):\n            row =[]\n            for c in range(n):\n                row.append(rowCount[r][1] + colCount[c][1] - \n                            rowCount[r][0] - colCount[c][0])\n            res.append(row)\n        return res",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "The main algorithmic approach used is \"Counting\" or more specifically \"Row and Column Counting\"."
  },
  {
    "title": "Minimum Penalty For A Shop",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def bestClosingTime(self, customers: str) -> int:\n        \n        curPenalty = res = minPenalty = 0\n\n        for i, ele in enumerate(customers):\n            if ele == 'Y':\n                curPenalty -= 1\n                if curPenalty < minPenalty:\n                    res = i+1\n                    curPenalty = minPenalty\n            else:\n                curPenalty += 1\n\n        return res",
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "tags": [],
    "approach": "Greedy"
  },
  {
    "title": "Maximum Number Of Integers To Choose From A Range I",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        nums = {x:1 for x in range(1, n + 1)} # hashmap for storing the required elements\n        for i in banned:\n            if nums.get(i):\n                del nums[i]\n        sum = 0\n        count = 0\n        for i in nums:\n            sum += i\n            if sum <= maxSum:\n                count += 1\n            else:\n                break\n        return count",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Minimize The Maximum Difference Of Pairs",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n        nums.sort()\n\n        def checkPair(mid):\n            count, i = 0, 0\n\n            while i < len(nums) - 1:\n                if nums[i + 1] - nums[i] <= mid:\n                    count += 1\n                    i += 2\n                else:\n                    i += 1\n\n            return count >= p\n\n        left, right = 0, nums[-1] - nums[0]\n\n        while left < right:\n            mid = (left + right) // 2\n\n            if checkPair(mid):\n                right = mid\n            else:\n                left = mid + 1\n\n        return left",
    "time_complexity": "Unknown",
    "space_complexity": "O(1)",
    "tags": [
      "math"
    ],
    "approach": "Binary Search"
  },
  {
    "title": "Greatest Common Divisor Traversal",
    "description": "No description available.",
    "optimal_code": "class UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.size = [1] * n\n        self.count = n\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return\n        if self.size[px] < self.size[py]:\n            self.par[px] = py\n            self.size[py] += self.size[px]\n        else:\n            self.par[py] = px\n            self.size[px] += self.size[py]\n        self.count -=1\n\nclass Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        uf = UnionFind(len(nums))\n\n        factor_index = {}\n        for i, n in enumerate(nums):\n            f = 2\n            while f * f <= n:\n                if n % f == 0:\n                    if f in factor_index:\n                        uf.union(i, factor_index[f])\n                    else:\n                        factor_index[f] = i\n                    while n % f == 0:\n                        n = n // f\n                f += 1\n            if n > 1:\n                if n in factor_index:\n                    uf.union(i, factor_index[n])\n                else:\n                    factor_index[n] = i\n        return uf.count == 1",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "tags": [
      "hash table",
      "math"
    ],
    "approach": "Dynamic Programming"
  },
  {
    "title": "Maximum Odd Binary Number",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def maximumOddBinaryNumber(self, s: str) -> str:\n        count = 0\n        for c in s:\n            if c == \"1\":\n                count += 1\n        \n        return (count - 1) * \"1\" + (len(s) - count) * \"0\" + \"1\"\n\nclass Solution:\n    def maximumOddBinaryNumber(self, s: str) -> str:\n        s = [c for c in s]\n        left = 0\n\n        for i in range(len(s)):\n            if s[i] == \"1\":\n                s[i], s[left] = s[left], s[i]\n                left += 1\n        s[left - 1], s[len(s) - 1] = s[len(s) - 1], s[left - 1]\n        return \"\".join(s)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "tags": [
      "array"
    ],
    "approach": "The main algorithmic approach used is \"Sorting\"."
  },
  {
    "title": "Find Polygon With The Largest Perimeter",
    "description": "No description available.",
    "optimal_code": "class Solution:\n    def largestPerimeter(self, nums: List[int]) -> int:\n        nums.sort()\n        res = -1\n        total = 0\n\n        for n in nums:\n            if total > n:\n                res = total + n\n            total += n\n        \n        return res\n\nclass Solution:\n    def largestPerimeter(self, nums: List[int]) -> int:\n        curSum = sum(nums)\n        heapq._heapify_max(nums)\n\n        while nums and curSum <= nums[0] * 2:\n            curSum -= heapq._heappop_max(nums)\n            \n        return curSum if len(nums) > 2 else -1",
    "time_complexity": "O(log n)",
    "space_complexity": "O(n)",
    "tags": [
      "binary search"
    ],
    "approach": "The main algorithmic approach used is: \"Sorting\"."
  }
]